{"mappings":"OAOA,SAASA,mBAEPC,EAEAC,GAEA,MAAMC,EAAeC,EAAiBC,IAAIJ,GAiB1C,YAfqBK,IAAjBH,GAGFC,EAAiBG,IAAIN,EAAkB,CAAEO,KAAM,GAAkBC,UAAW,CAACP,KAE/C,IAA1BE,EAAiBM,OAEnBC,EAAQC,sBAAsBC,MAIhCV,EAAaM,UAAUK,KAAKZ,GAC5BA,EAASD,EAAiBc,0BAGrB,KACL,MAAMZ,EAAeC,EAAiBC,IAAIJ,GAC1C,QAAqBK,IAAjBH,EAA4B,OAGhC,MAAMa,EAAQb,EAAaM,UAAUQ,QAAQf,GACzCc,GAAS,GACXb,EAAaM,UAAUS,OAAOF,EAAO,GAGD,IAAlCb,EAAaM,UAAUU,SAGzBf,EAAiBgB,OAAOnB,GAEM,IAA1BG,EAAiBM,MAEnBW,qBAAqBV,KAgB7B,IAAIA,EACJ,MAAMP,EAAkD,IAAIkB,IAE5D,SAAST,IACP,MAAMU,EAAwC,GAG9CnB,EAAiBoB,SAAQ,CAACC,EAAMC,KAC9B,MAAMC,EAAUD,EAAQX,wBAsB5B,IAAoBa,EAAmBC,EAAnBD,EAnBAH,EAAKjB,KAmBcqB,EAnBRF,GAqB3BC,EAAME,QAAUD,EAAMC,OACtBF,EAAMG,SAAWF,EAAME,QACvBH,EAAMI,MAAQH,EAAMG,KACpBJ,EAAMK,QAAUJ,EAAMI,OACtBL,EAAMM,SAAWL,EAAMK,QACvBN,EAAMO,OAASN,EAAMM,QAzBnBV,EAAKjB,KAAOmB,EACZJ,EAAiBT,KAAKW,OAM1BF,EAAiBC,SAASC,IACxBA,EAAKhB,UAAUe,SAAStB,GAAaA,EAASuB,EAAKjB,WAGrDG,EAAQC,sBAAsBC","sources":["./packages/core/rect/src/observeElementRect.ts"],"sourcesContent":["type Measurable = { getBoundingClientRect(): ClientRect };\n\n/**\n * Observes an element's rectangle on screen (getBoundingClientRect)\n * This is useful to track elements on the screen and attach other elements\n * that might be in different layers, etc.\n */\nfunction observeElementRect(\n  /** The element whose rect to observe */\n  elementToObserve: Measurable,\n  /** The callback which will be called when the rect changes */\n  callback: CallbackFn\n) {\n  const observedData = observedElements.get(elementToObserve);\n\n  if (observedData === undefined) {\n    // add the element to the map of observed elements with its first callback\n    // because this is the first time this element is observed\n    observedElements.set(elementToObserve, { rect: {} as ClientRect, callbacks: [callback] });\n\n    if (observedElements.size === 1) {\n      // start the internal loop once at least 1 element is observed\n      rafId = requestAnimationFrame(runLoop);\n    }\n  } else {\n    // only add a callback for this element as it's already observed\n    observedData.callbacks.push(callback);\n    callback(elementToObserve.getBoundingClientRect());\n  }\n\n  return () => {\n    const observedData = observedElements.get(elementToObserve);\n    if (observedData === undefined) return;\n\n    // start by removing the callback\n    const index = observedData.callbacks.indexOf(callback);\n    if (index > -1) {\n      observedData.callbacks.splice(index, 1);\n    }\n\n    if (observedData.callbacks.length === 0) {\n      // stop observing this element because there are no\n      // callbacks registered for it anymore\n      observedElements.delete(elementToObserve);\n\n      if (observedElements.size === 0) {\n        // stop the internal loop once no elements are observed anymore\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\n// ========================================================================\n// module internals\n\ntype CallbackFn = (rect: ClientRect) => void;\n\ntype ObservedData = {\n  rect: ClientRect;\n  callbacks: Array<CallbackFn>;\n};\n\nlet rafId: number;\nconst observedElements: Map<Measurable, ObservedData> = new Map();\n\nfunction runLoop() {\n  const changedRectsData: Array<ObservedData> = [];\n\n  // process all DOM reads first (getBoundingClientRect)\n  observedElements.forEach((data, element) => {\n    const newRect = element.getBoundingClientRect();\n\n    // gather all the data for elements whose rects have changed\n    if (!rectEquals(data.rect, newRect)) {\n      data.rect = newRect;\n      changedRectsData.push(data);\n    }\n  });\n\n  // group DOM writes here after the DOM reads (getBoundingClientRect)\n  // as DOM writes will most likely happen with the callbacks\n  changedRectsData.forEach((data) => {\n    data.callbacks.forEach((callback) => callback(data.rect));\n  });\n\n  rafId = requestAnimationFrame(runLoop);\n}\n// ========================================================================\n\n/**\n * Returns whether 2 rects are equal in values\n */\nfunction rectEquals(rect1: ClientRect, rect2: ClientRect) {\n  return (\n    rect1.width === rect2.width &&\n    rect1.height === rect2.height &&\n    rect1.top === rect2.top &&\n    rect1.right === rect2.right &&\n    rect1.bottom === rect2.bottom &&\n    rect1.left === rect2.left\n  );\n}\n\nexport { observeElementRect };\nexport type { Measurable };\n"],"names":["observeElementRect","elementToObserve","callback","observedData","observedElements","get","undefined","set","rect","callbacks","size","rafId","requestAnimationFrame","runLoop","push","getBoundingClientRect","index","indexOf","splice","length","delete","cancelAnimationFrame","Map","changedRectsData","forEach","data","element","newRect","rect1","rect2","width","height","top","right","bottom","left"],"version":3,"file":"index.module.js.map"}