import * as React from "react";
import * as THREE from "three";
import { XRControllerModelFactory } from "three-stdlib";
import { useFrame, extend, createPortal } from "@react-three/fiber";
import { useXR } from "./XR.mjs";
const Ray = React.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState);
  const ray = React.useRef(null);
  const rayGeometry = React.useMemo(
    () => new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
    []
  );
  React.useImperativeHandle(forwardedRef, () => ray.current);
  useFrame(() => {
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return /* @__PURE__ */ React.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
const modelFactory = new XRControllerModelFactory();
class ControllerModel extends THREE.Group {
  constructor(target) {
    super();
    this.add(modelFactory.createControllerModel(target.controller));
  }
}
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false }) {
  const controllers = useXR((state) => state.controllers);
  const isHandTracking = useXR((state) => state.isHandTracking);
  const rayMaterialProps = React.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React.useMemo(() => extend({ ControllerModel }), []);
  React.useEffect(() => {
    for (const target of controllers) {
      target.controller.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, controllers.map((target, i) => /* @__PURE__ */ React.createElement(React.Fragment, {
    key: i
  }, createPortal(/* @__PURE__ */ React.createElement("controllerModel", {
    args: [target]
  }), target.grip), createPortal(
    /* @__PURE__ */ React.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}
export {
  Controllers,
  Ray
};
//# sourceMappingURL=Controllers.mjs.map
