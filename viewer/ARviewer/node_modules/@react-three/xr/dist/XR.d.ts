/// <reference types="webxr" />
import * as React from 'react';
import * as THREE from 'three';
import { EqualityChecker, GetState, SetState, StateSelector } from 'zustand';
import { XRController } from './XRController';
import { XRInteractionHandler, XRInteractionType } from './Interactions';
import { XREventHandler } from './XREvents';
export interface XRState {
    set: SetState<XRState>;
    get: GetState<XRState>;
    controllers: XRController[];
    isPresenting: boolean;
    isHandTracking: boolean;
    player: THREE.Group;
    session: XRSession | null;
    foveation: number;
    referenceSpace: XRReferenceSpaceType;
    hoverState: Record<XRHandedness, Map<THREE.Object3D, THREE.Intersection>>;
    interactions: Map<THREE.Object3D, Record<XRInteractionType, React.RefObject<XRInteractionHandler>[]>>;
    hasInteraction: (object: THREE.Object3D, eventType: XRInteractionType) => boolean;
    getInteraction: (object: THREE.Object3D, eventType: XRInteractionType) => XRInteractionHandler[] | undefined;
    addInteraction: (object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) => void;
    removeInteraction: (object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) => void;
}
export declare type XRManagerEventType = 'sessionstart' | 'sessionend';
export interface XRManagerEvent {
    type: XRManagerEventType;
    target: XRSession;
}
export interface XRProps {
    /**
     * Enables foveated rendering. `Default is `0`
     * 0 = no foveation, full resolution
     * 1 = maximum foveation, the edges render at lower resolution
     */
    foveation?: number;
    /** Type of WebXR reference space to use. Default is `local-space` */
    referenceSpace?: XRReferenceSpaceType;
    /** Called as an XRSession is requested */
    onSessionStart?: XREventHandler<XRManagerEvent>;
    /** Called after an XRSession is terminated */
    onSessionEnd?: XREventHandler<XRManagerEvent>;
    /** Called when an XRSession is hidden or unfocused. */
    onVisibilityChange?: XREventHandler<XRSessionEvent>;
    /** Called when available inputsources change */
    onInputSourcesChange?: XREventHandler<XRSessionEvent>;
    children: React.ReactNode;
}
export declare function XR(props: XRProps): JSX.Element;
export declare type XRButtonStatus = 'unsupported' | 'exited' | 'entered';
export interface XRButtonProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'children'> {
    /** The type of `XRSession` to create */
    mode: 'AR' | 'VR' | 'inline';
    /**
     * `XRSession` configuration options
     * @see https://immersive-web.github.io/webxr/#feature-dependencies
     */
    sessionInit?: XRSessionInit;
    /** Whether this button should only enter an `XRSession`. Default is `false` */
    enterOnly?: boolean;
    /** Whether this button should only exit an `XRSession`. Default is `false` */
    exitOnly?: boolean;
    /** React children, can also accept a callback returning an `XRButtonStatus` */
    children?: React.ReactNode | ((status: XRButtonStatus) => React.ReactNode);
}
export declare const XRButton: React.ForwardRefExoticComponent<XRButtonProps & React.RefAttributes<HTMLButtonElement>>;
export declare const ARButton: React.ForwardRefExoticComponent<Omit<XRButtonProps, "mode"> & React.RefAttributes<HTMLButtonElement>>;
export declare const VRButton: React.ForwardRefExoticComponent<Omit<XRButtonProps, "mode"> & React.RefAttributes<HTMLButtonElement>>;
export declare function useXR<T = XRState>(selector?: StateSelector<XRState, T>, equalityFn?: EqualityChecker<T>): T;
export declare function useController(handedness: XRHandedness): XRController | undefined;
