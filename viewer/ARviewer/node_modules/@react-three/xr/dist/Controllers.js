"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const React = require("react");
const THREE = require("three");
const threeStdlib = require("three-stdlib");
const fiber = require("@react-three/fiber");
const XR = require("./XR.js");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespace(React);
const THREE__namespace = /* @__PURE__ */ _interopNamespace(THREE);
const Ray = React__namespace.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = XR.useXR((state) => state.hoverState);
  const ray = React__namespace.useRef(null);
  const rayGeometry = React__namespace.useMemo(
    () => new THREE__namespace.BufferGeometry().setFromPoints([new THREE__namespace.Vector3(0, 0, 0), new THREE__namespace.Vector3(0, 0, -1)]),
    []
  );
  React__namespace.useImperativeHandle(forwardedRef, () => ray.current);
  fiber.useFrame(() => {
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return /* @__PURE__ */ React__namespace.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
const modelFactory = new threeStdlib.XRControllerModelFactory();
class ControllerModel extends THREE__namespace.Group {
  constructor(target) {
    super();
    this.add(modelFactory.createControllerModel(target.controller));
  }
}
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false }) {
  const controllers = XR.useXR((state) => state.controllers);
  const isHandTracking = XR.useXR((state) => state.isHandTracking);
  const rayMaterialProps = React__namespace.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React__namespace.useMemo(() => fiber.extend({ ControllerModel }), []);
  React__namespace.useEffect(() => {
    for (const target of controllers) {
      target.controller.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers]);
  return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, controllers.map((target, i) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
    key: i
  }, fiber.createPortal(/* @__PURE__ */ React__namespace.createElement("controllerModel", {
    args: [target]
  }), target.grip), fiber.createPortal(
    /* @__PURE__ */ React__namespace.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}
exports.Controllers = Controllers;
exports.Ray = Ray;
//# sourceMappingURL=Controllers.js.map
