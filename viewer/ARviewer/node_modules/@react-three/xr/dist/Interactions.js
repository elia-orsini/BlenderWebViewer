"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const React = require("react");
const THREE = require("three");
const fiber = require("@react-three/fiber");
const XR = require("./XR.js");
const XREvents = require("./XREvents.js");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespace(React);
const THREE__namespace = /* @__PURE__ */ _interopNamespace(THREE);
const tempMatrix = new THREE__namespace.Matrix4();
function InteractionManager({ children }) {
  const events = fiber.useThree((state) => state.events);
  const get = fiber.useThree((state) => state.get);
  const raycaster = fiber.useThree((state) => state.raycaster);
  const controllers = XR.useXR((state) => state.controllers);
  const interactions = XR.useXR((state) => state.interactions);
  const hoverState = XR.useXR((state) => state.hoverState);
  const hasInteraction = XR.useXR((state) => state.hasInteraction);
  const getInteraction = XR.useXR((state) => state.getInteraction);
  const intersect = React__namespace.useCallback(
    (controller) => {
      const objects = Array.from(interactions.keys());
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(objects, true);
    },
    [interactions, raycaster]
  );
  fiber.useFrame(() => {
    if (interactions.size === 0)
      return;
    for (const target of controllers) {
      const hovering = hoverState[target.inputSource.handedness];
      const hits = /* @__PURE__ */ new Set();
      let intersections = intersect(target.controller);
      if (events.filter) {
        intersections = events.filter(intersections, get());
      } else {
        const hit = intersections.find((i) => i == null ? void 0 : i.object);
        if (hit)
          intersections = [hit];
      }
      for (const intersection of intersections) {
        let eventObject = intersection.object;
        while (eventObject) {
          if (hasInteraction(eventObject, "onHover") && !hovering.has(eventObject)) {
            const handlers = getInteraction(eventObject, "onHover");
            for (const handler of handlers) {
              handler({ target, intersection, intersections });
            }
          }
          const moveHandlers = getInteraction(eventObject, "onMove");
          moveHandlers == null ? void 0 : moveHandlers.forEach((handler) => handler({ target, intersection, intersections }));
          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }
      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          hovering.delete(eventObject);
          const handlers = getInteraction(eventObject, "onBlur");
          if (!handlers)
            continue;
          for (const handler of handlers) {
            handler({ target, intersections });
          }
        }
      }
    }
  });
  const triggerEvent = React__namespace.useCallback(
    (interaction) => (e) => {
      const hovering = hoverState[e.target.inputSource.handedness];
      const intersections = Array.from(new Set(hovering.values()));
      interactions.forEach((handlers, object) => {
        var _a, _b, _c;
        if (hovering.has(object)) {
          if (!handlers[interaction])
            return;
          for (const handler of handlers[interaction]) {
            (_a = handler.current) == null ? void 0 : _a.call(handler, { target: e.target, intersection: hovering.get(object), intersections });
          }
        } else {
          if (interaction === "onSelect" && handlers["onSelectMissed"]) {
            for (const handler of handlers["onSelectMissed"]) {
              (_b = handler.current) == null ? void 0 : _b.call(handler, { target: e.target, intersections });
            }
          } else if (interaction === "onSqueeze" && handlers["onSqueezeMissed"]) {
            for (const handler of handlers["onSqueezeMissed"]) {
              (_c = handler.current) == null ? void 0 : _c.call(handler, { target: e.target, intersections });
            }
          }
        }
      });
    },
    [hoverState, interactions]
  );
  XREvents.useXREvent("select", triggerEvent("onSelect"));
  XREvents.useXREvent("selectstart", triggerEvent("onSelectStart"));
  XREvents.useXREvent("selectend", triggerEvent("onSelectEnd"));
  XREvents.useXREvent("squeeze", triggerEvent("onSqueeze"));
  XREvents.useXREvent("squeezeend", triggerEvent("onSqueezeEnd"));
  XREvents.useXREvent("squeezestart", triggerEvent("onSqueezeStart"));
  return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, children);
}
function useInteraction(ref, type, handler) {
  const addInteraction = XR.useXR((state) => state.addInteraction);
  const removeInteraction = XR.useXR((state) => state.removeInteraction);
  const handlerRef = React__namespace.useRef(handler != null ? handler : null);
  React__namespace.useEffect(() => void (handlerRef.current = handler != null ? handler : null), [handler]);
  React__namespace.useEffect(() => {
    const target = ref.current;
    if (!target || !handlerRef.current)
      return;
    addInteraction(target, type, handlerRef);
    return () => removeInteraction(target, type, handlerRef);
  }, [ref, type, addInteraction, removeInteraction]);
}
const Interactive = React__namespace.forwardRef(function Interactive2({
  onHover,
  onBlur,
  onSelectStart,
  onSelectEnd,
  onSelectMissed,
  onSelect,
  onSqueezeStart,
  onSqueezeEnd,
  onSqueezeMissed,
  onSqueeze,
  onMove,
  children
}, passedRef) {
  const ref = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelectMissed", onSelectMissed);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueezeMissed", onSqueezeMissed);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return /* @__PURE__ */ React__namespace.createElement("group", {
    ref
  }, children);
});
const RayGrab = React__namespace.forwardRef(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = React__namespace.useRef();
  const groupRef = React__namespace.useRef(null);
  const previousTransform = React__namespace.useMemo(() => new THREE__namespace.Matrix4(), []);
  React__namespace.useImperativeHandle(forwardedRef, () => groupRef.current);
  fiber.useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!controller)
      return;
    group.applyMatrix4(previousTransform);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return /* @__PURE__ */ React__namespace.createElement(Interactive, {
    ref: groupRef,
    onSelectStart: (e) => {
      grabbingController.current = e.target.controller;
      previousTransform.copy(e.target.controller.matrixWorld).invert();
      onSelectStart == null ? void 0 : onSelectStart(e);
    },
    onSelectEnd: (e) => {
      if (e.target.controller === grabbingController.current) {
        grabbingController.current = void 0;
      }
      onSelectEnd == null ? void 0 : onSelectEnd(e);
    },
    ...rest
  }, children);
});
function useHitTest(hitTestCallback) {
  const session = XR.useXR((state) => state.session);
  const hitTestSource = React__namespace.useRef();
  const hitMatrix = React__namespace.useMemo(() => new THREE__namespace.Matrix4(), []);
  React__namespace.useEffect(() => {
    if (!session)
      return void (hitTestSource.current = void 0);
    session.requestReferenceSpace("viewer").then(async (referenceSpace) => {
      var _a;
      hitTestSource.current = await ((_a = session == null ? void 0 : session.requestHitTestSource) == null ? void 0 : _a.call(session, { space: referenceSpace }));
    });
  }, [session]);
  fiber.useFrame((state, _, frame) => {
    if (!frame || !hitTestSource.current)
      return;
    const [hit] = frame.getHitTestResults(hitTestSource.current);
    if (hit) {
      const referenceSpace = state.gl.xr.getReferenceSpace();
      const pose = hit.getPose(referenceSpace);
      if (pose) {
        hitMatrix.fromArray(pose.transform.matrix);
        hitTestCallback(hitMatrix, hit);
      }
    }
  });
}
exports.InteractionManager = InteractionManager;
exports.Interactive = Interactive;
exports.RayGrab = RayGrab;
exports.useHitTest = useHitTest;
exports.useInteraction = useInteraction;
//# sourceMappingURL=Interactions.js.map
