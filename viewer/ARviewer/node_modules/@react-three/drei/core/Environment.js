import * as React from 'react';
import { useThree, useFrame, createPortal, useLoader } from '@react-three/fiber';
import { Scene, WebGLCubeRenderTarget, HalfFloatType, FloatType, CubeReflectionMapping, EquirectangularReflectionMapping, CubeTextureLoader } from 'three';
import { RGBELoader } from 'three-stdlib';
import { presetsObj } from '../helpers/environment-assets.js';

const CUBEMAP_ROOT = 'https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/';

const isRef = obj => obj.current && obj.current.isScene;

const resolveScene = scene => isRef(scene) ? scene.current : scene;

function Environment(props) {
  return props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);
}
function EnvironmentMap({
  scene,
  background = false,
  map
}) {
  const defaultScene = useThree(state => state.scene);
  React.useLayoutEffect(() => {
    if (map) {
      const target = resolveScene(scene || defaultScene);
      const oldbg = target.background;
      const oldenv = target.environment;
      if (background !== 'only') target.environment = map;
      if (background) target.background = map;
      return () => {
        if (background !== 'only') target.environment = oldenv;
        if (background) target.background = oldbg;
      };
    }
  }, [scene, map]);
  return null;
}
function EnvironmentPortal({
  children,
  near = 1,
  far = 1000,
  resolution = 256,
  frames = 1,
  background = false,
  scene,
  files,
  path,
  preset = undefined,
  extensions
}) {
  const gl = useThree(state => state.gl);
  const defaultScene = useThree(state => state.scene);
  const camera = React.useRef(null);
  const [virtualScene] = React.useState(() => new Scene());
  const fbo = React.useMemo(() => {
    const fbo = new WebGLCubeRenderTarget(resolution);
    fbo.texture.type = HalfFloatType;
    return fbo;
  }, [resolution]);
  React.useLayoutEffect(() => {
    if (frames === 1) camera.current.update(gl, virtualScene);
    const target = resolveScene(scene || defaultScene);
    const oldbg = target.background;
    const oldenv = target.environment;
    if (background !== 'only') target.environment = fbo.texture;
    if (background) target.background = fbo.texture;
    return () => {
      if (background !== 'only') target.environment = oldenv;
      if (background) target.background = oldbg;
    };
  }, [children, scene]);
  let count = 1;
  useFrame(() => {
    if (frames === Infinity || count < frames) {
      camera.current.update(gl, virtualScene);
      count++;
    }
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement("cubeCamera", {
    ref: camera,
    args: [near, far, fbo]
  }), (files || preset) && /*#__PURE__*/React.createElement(EnvironmentMap, {
    background: true,
    files: files,
    preset: preset,
    path: path,
    extensions: extensions,
    scene: virtualScene
  })), virtualScene));
}
function EnvironmentCube({
  background = false,
  files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],
  path = '',
  preset = undefined,
  scene,
  extensions
}) {
  if (preset) {
    if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));
    files = presetsObj[preset];
    path = CUBEMAP_ROOT;
  }

  const defaultScene = useThree(state => state.scene);
  const isCubeMap = Array.isArray(files);
  const loader = isCubeMap ? CubeTextureLoader : RGBELoader; // @ts-expect-error

  const loaderResult = useLoader(loader, isCubeMap ? [files] : files, loader => {
    loader.setPath(path); // @ts-expect-error

    loader.setDataType == null ? void 0 : loader.setDataType(FloatType);
    if (extensions) extensions(loader);
  });
  const texture = isCubeMap ? loaderResult[0] : loaderResult;
  texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;
  React.useLayoutEffect(() => {
    const target = resolveScene(scene || defaultScene);
    const oldbg = target.background;
    const oldenv = target.environment;
    if (background !== 'only') target.environment = texture;
    if (background) target.background = texture;
    return () => {
      if (background !== 'only') target.environment = oldenv;
      if (background) target.background = oldbg;
    };
  }, [texture, background, scene]);
  return null;
}

export { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal };
