"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");const t=new e.Matrix4,s=new e.Object3D,o=new e.Vector3;class r extends e.EventDispatcher{constructor(){super(),this.isGeometry=!0,this.uuid=e.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(t){const s=(new e.Matrix3).getNormalMatrix(t);for(let e=0,s=this.vertices.length;e<s;e++){this.vertices[e].applyMatrix4(t)}for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal.applyMatrix3(s).normalize();for(let e=0,o=t.vertexNormals.length;e<o;e++)t.vertexNormals[e].applyMatrix3(s).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(e){return t.makeRotationX(e),this.applyMatrix4(t),this}rotateY(e){return t.makeRotationY(e),this.applyMatrix4(t),this}rotateZ(e){return t.makeRotationZ(e),this.applyMatrix4(t),this}translate(e,s,o){return t.makeTranslation(e,s,o),this.applyMatrix4(t),this}scale(e,s,o){return t.makeScale(e,s,o),this.applyMatrix4(t),this}lookAt(e){return s.lookAt(e),s.updateMatrix(),this.applyMatrix4(s.matrix),this}fromBufferGeometry(t){const s=this,o=null!==t.index?t.index:void 0,r=t.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const n=r.position,l=r.normal,a=r.color,c=r.uv,h=r.uv2;void 0!==h&&(this.faceVertexUvs[1]=[]);for(let t=0;t<n.count;t++)s.vertices.push((new e.Vector3).fromBufferAttribute(n,t)),void 0!==a&&s.colors.push((new e.Color).fromBufferAttribute(a,t));function u(t,o,r,n){const u=void 0===a?[]:[s.colors[t].clone(),s.colors[o].clone(),s.colors[r].clone()],p=void 0===l?[]:[(new e.Vector3).fromBufferAttribute(l,t),(new e.Vector3).fromBufferAttribute(l,o),(new e.Vector3).fromBufferAttribute(l,r)],m=new i(t,o,r,p,u,n);s.faces.push(m),void 0!==c&&s.faceVertexUvs[0].push([(new e.Vector2).fromBufferAttribute(c,t),(new e.Vector2).fromBufferAttribute(c,o),(new e.Vector2).fromBufferAttribute(c,r)]),void 0!==h&&s.faceVertexUvs[1].push([(new e.Vector2).fromBufferAttribute(h,t),(new e.Vector2).fromBufferAttribute(h,o),(new e.Vector2).fromBufferAttribute(h,r)])}const p=t.groups;if(p.length>0)for(let e=0;e<p.length;e++){const t=p[e],s=t.start;for(let e=s,r=s+t.count;e<r;e+=3)void 0!==o?u(o.getX(e),o.getX(e+1),o.getX(e+2),t.materialIndex):u(e,e+1,e+2,t.materialIndex)}else if(void 0!==o)for(let e=0;e<o.count;e+=3)u(o.getX(e),o.getX(e+1),o.getX(e+2));else for(let e=0;e<n.count;e+=3)u(e,e+1,e+2);return this.computeFaceNormals(),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(o).negate(),this.translate(o.x,o.y,o.z),this}normalize(){this.computeBoundingSphere();const t=this.boundingSphere.center,s=this.boundingSphere.radius,o=0===s?1:1/s,r=new e.Matrix4;return r.set(o,0,0,-o*t.x,0,o,0,-o*t.y,0,0,o,-o*t.z,0,0,0,1),this.applyMatrix4(r),this}computeFaceNormals(){const t=new e.Vector3,s=new e.Vector3;for(let e=0,o=this.faces.length;e<o;e++){const o=this.faces[e],r=this.vertices[o.a],n=this.vertices[o.b],i=this.vertices[o.c];t.subVectors(i,n),s.subVectors(r,n),t.cross(s),t.normalize(),o.normal.copy(t)}}computeVertexNormals(t=!0){const s=new Array(this.vertices.length);for(let t=0,o=this.vertices.length;t<o;t++)s[t]=new e.Vector3;if(t){const t=new e.Vector3,o=new e.Vector3;for(let e=0,r=this.faces.length;e<r;e++){const r=this.faces[e],n=this.vertices[r.a],i=this.vertices[r.b],l=this.vertices[r.c];t.subVectors(l,i),o.subVectors(n,i),t.cross(o),s[r.a].add(t),s[r.b].add(t),s[r.c].add(t)}}else{this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];s[t.a].add(t.normal),s[t.b].add(t.normal),s[t.c].add(t.normal)}}for(let e=0,t=this.vertices.length;e<t;e++)s[e].normalize();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=t.vertexNormals;3===o.length?(o[0].copy(s[t.a]),o[1].copy(s[t.b]),o[2].copy(s[t.c])):(o[0]=s[t.a].clone(),o[1]=s[t.b].clone(),o[2]=s[t.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.__originalFaceNormal?t.__originalFaceNormal.copy(t.normal):t.__originalFaceNormal=t.normal.clone(),t.__originalVertexNormals||(t.__originalVertexNormals=[]);for(let e=0,s=t.vertexNormals.length;e<s;e++)t.__originalVertexNormals[e]?t.__originalVertexNormals[e].copy(t.vertexNormals[e]):t.__originalVertexNormals[e]=t.vertexNormals[e].clone()}const t=new r;t.faces=this.faces;for(let s=0,o=this.morphTargets.length;s<o;s++){if(!this.morphNormals[s]){this.morphNormals[s]={},this.morphNormals[s].faceNormals=[],this.morphNormals[s].vertexNormals=[];const t=this.morphNormals[s].faceNormals,o=this.morphNormals[s].vertexNormals;for(let s=0,r=this.faces.length;s<r;s++){const s=new e.Vector3,r={a:new e.Vector3,b:new e.Vector3,c:new e.Vector3};t.push(s),o.push(r)}}const o=this.morphNormals[s];t.vertices=this.morphTargets[s].vertices,t.computeFaceNormals(),t.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=o.faceNormals[e],r=o.vertexNormals[e];s.copy(t.normal),r.a.copy(t.vertexNormals[0]),r.b.copy(t.vertexNormals[1]),r.c.copy(t.vertexNormals[2])}}for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal=t.__originalFaceNormal,t.vertexNormals=t.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new e.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new e.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(t,s,o=0){if(!t||!t.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",t);let r;const n=this.vertices.length,l=this.vertices,a=t.vertices,c=this.faces,h=t.faces,u=this.colors,p=t.colors;void 0!==s&&(r=(new e.Matrix3).getNormalMatrix(s));for(let e=0,t=a.length;e<t;e++){const t=a[e].clone();void 0!==s&&t.applyMatrix4(s),l.push(t)}for(let e=0,t=p.length;e<t;e++)u.push(p[e].clone());for(let e=0,t=h.length;e<t;e++){const t=h[e];let s,l;const a=t.vertexNormals,u=t.vertexColors,p=new i(t.a+n,t.b+n,t.c+n);p.normal.copy(t.normal),void 0!==r&&p.normal.applyMatrix3(r).normalize();for(let e=0,t=a.length;e<t;e++)s=a[e].clone(),void 0!==r&&s.applyMatrix3(r).normalize(),p.vertexNormals.push(s);p.color.copy(t.color);for(let e=0,t=u.length;e<t;e++)l=u[e],p.vertexColors.push(l.clone());p.materialIndex=t.materialIndex+o,c.push(p)}for(let e=0,s=t.faceVertexUvs.length;e<s;e++){const s=t.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let t=0,o=s.length;t<o;t++){const o=s[t],r=[];for(let e=0,t=o.length;e<t;e++)r.push(o[e].clone());this.faceVertexUvs[e].push(r)}}}mergeMesh(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)}mergeVertices(e=4){const t={},s=[],o=[],r=Math.pow(10,e);for(let e=0,n=this.vertices.length;e<n;e++){const n=this.vertices[e],i=`${Math.round(n.x*r)}_${Math.round(n.y*r)}_${Math.round(n.z*r)}`;void 0===t[i]?(t[i]=e,s.push(this.vertices[e]),o[e]=s.length-1):o[e]=o[t[i]]}const n=[];for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.a=o[t.a],t.b=o[t.b],t.c=o[t.c];const s=[t.a,t.b,t.c];for(let t=0;t<3;t++)if(s[t]===s[(t+1)%3]){n.push(e);break}}for(let e=n.length-1;e>=0;e--){const t=n[e];this.faces.splice(t,1);for(let e=0,s=this.faceVertexUvs.length;e<s;e++)this.faceVertexUvs[e].splice(t,1)}const i=this.vertices.length-s.length;return this.vertices=s,i}setFromPoints(t){this.vertices=[];for(let s=0,o=t.length;s<o;s++){const o=t[s];this.vertices.push(new e.Vector3(o.x,o.y,o.z||0))}return this}sortFacesByMaterialIndex(){const e=this.faces,t=e.length;for(let s=0;s<t;s++)e[s]._id=s;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let r,n;s&&s.length===t&&(r=[]),o&&o.length===t&&(n=[]);for(let i=0;i<t;i++){const t=e[i]._id;r&&r.push(s[t]),n&&n.push(o[t])}r&&(this.faceVertexUvs[0]=r),n&&(this.faceVertexUvs[1]=n)}toJSON(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(let s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];t.push(s.x,s.y,s.z)}const s=[],o=[],r={},n=[],i={},l=[],a={};for(let e=0;e<this.faces.length;e++){const t=this.faces[e],o=!0,r=!1,n=void 0!==this.faceVertexUvs[0][e],i=t.normal.length()>0,l=t.vertexNormals.length>0,a=1!==t.color.r||1!==t.color.g||1!==t.color.b,m=t.vertexColors.length>0;let f=0;if(f=c(f,0,0),f=c(f,1,o),f=c(f,2,r),f=c(f,3,n),f=c(f,4,i),f=c(f,5,l),f=c(f,6,a),f=c(f,7,m),s.push(f),s.push(t.a,t.b,t.c),s.push(t.materialIndex),n){const t=this.faceVertexUvs[0][e];s.push(p(t[0]),p(t[1]),p(t[2]))}if(i&&s.push(h(t.normal)),l){const e=t.vertexNormals;s.push(h(e[0]),h(e[1]),h(e[2]))}if(a&&s.push(u(t.color)),m){const e=t.vertexColors;s.push(u(e[0]),u(e[1]),u(e[2]))}}function c(e,t,s){return s?e|1<<t:e&~(1<<t)}function h(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==r[t]||(r[t]=o.length/3,o.push(e.x,e.y,e.z)),r[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=n.length,n.push(e.getHex())),i[t]}function p(e){const t=e.x.toString()+e.y.toString();return void 0!==a[t]||(a[t]=l.length/2,l.push(e.x,e.y)),a[t]}return e.data={},e.data.vertices=t,e.data.normals=o,n.length>0&&(e.data.colors=n),l.length>0&&(e.data.uvs=[l]),e.data.faces=s,e}clone(){return(new r).copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let e=0,s=t.length;e<s;e++)this.vertices.push(t[e].clone());const s=e.colors;for(let e=0,t=s.length;e<t;e++)this.colors.push(s[e].clone());const o=e.faces;for(let e=0,t=o.length;e<t;e++)this.faces.push(o[e].clone());for(let t=0,s=e.faceVertexUvs.length;t<s;t++){const s=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,o=s.length;e<o;e++){const o=s[e],r=[];for(let e=0,t=o.length;e<t;e++){const t=o[e];r.push(t.clone())}this.faceVertexUvs[t].push(r)}}const r=e.morphTargets;for(let e=0,t=r.length;e<t;e++){const t={};if(t.name=r[e].name,void 0!==r[e].vertices){t.vertices=[];for(let s=0,o=r[e].vertices.length;s<o;s++)t.vertices.push(r[e].vertices[s].clone())}if(void 0!==r[e].normals){t.normals=[];for(let s=0,o=r[e].normals.length;s<o;s++)t.normals.push(r[e].normals[s].clone())}this.morphTargets.push(t)}const n=e.morphNormals;for(let e=0,t=n.length;e<t;e++){const t={};if(void 0!==n[e].vertexNormals){t.vertexNormals=[];for(let s=0,o=n[e].vertexNormals.length;s<o;s++){const o=n[e].vertexNormals[s],r={};r.a=o.a.clone(),r.b=o.b.clone(),r.c=o.c.clone(),t.vertexNormals.push(r)}}if(void 0!==n[e].faceNormals){t.faceNormals=[];for(let s=0,o=n[e].faceNormals.length;s<o;s++)t.faceNormals.push(n[e].faceNormals[s].clone())}this.morphNormals.push(t)}const i=e.skinWeights;for(let e=0,t=i.length;e<t;e++)this.skinWeights.push(i[e].clone());const l=e.skinIndices;for(let e=0,t=l.length;e<t;e++)this.skinIndices.push(l[e].clone());const a=e.lineDistances;for(let e=0,t=a.length;e<t;e++)this.lineDistances.push(a[e]);const c=e.boundingBox;null!==c&&(this.boundingBox=c.clone());const h=e.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){const t=(new n).fromGeometry(this),s=new e.BufferGeometry,o=new Float32Array(3*t.vertices.length);if(s.setAttribute("position",new e.BufferAttribute(o,3).copyVector3sArray(t.vertices)),t.normals.length>0){const o=new Float32Array(3*t.normals.length);s.setAttribute("normal",new e.BufferAttribute(o,3).copyVector3sArray(t.normals))}if(t.colors.length>0){const o=new Float32Array(3*t.colors.length);s.setAttribute("color",new e.BufferAttribute(o,3).copyColorsArray(t.colors))}if(t.uvs.length>0){const o=new Float32Array(2*t.uvs.length);s.setAttribute("uv",new e.BufferAttribute(o,2).copyVector2sArray(t.uvs))}if(t.uvs2.length>0){const o=new Float32Array(2*t.uvs2.length);s.setAttribute("uv2",new e.BufferAttribute(o,2).copyVector2sArray(t.uvs2))}s.groups=t.groups;for(let o in t.morphTargets){const r=[],n=t.morphTargets[o];for(let t=0,s=n.length;t<s;t++){const s=n[t],o=new e.Float32BufferAttribute(3*s.data.length,3);o.name=s.name,r.push(o.copyVector3sArray(s.data))}s.morphAttributes[o]=r}if(t.skinIndices.length>0){const o=new e.Float32BufferAttribute(4*t.skinIndices.length,4);s.setAttribute("skinIndex",o.copyVector4sArray(t.skinIndices))}if(t.skinWeights.length>0){const o=new e.Float32BufferAttribute(4*t.skinWeights.length,4);s.setAttribute("skinWeight",o.copyVector4sArray(t.skinWeights))}return null!==t.boundingSphere&&(s.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(s.boundingBox=t.boundingBox.clone()),s}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){this.dispatchEvent({type:"dispose"})}}r.createBufferGeometryFromObject=t=>{let s=new e.BufferGeometry;const o=t.geometry;if(t.isPoints||t.isLine){const t=new e.Float32BufferAttribute(3*o.vertices.length,3),r=new e.Float32BufferAttribute(3*o.colors.length,3);if(s.setAttribute("position",t.copyVector3sArray(o.vertices)),s.setAttribute("color",r.copyColorsArray(o.colors)),o.lineDistances&&o.lineDistances.length===o.vertices.length){const t=new e.Float32BufferAttribute(o.lineDistances.length,1);s.setAttribute("lineDistance",t.copyArray(o.lineDistances))}null!==o.boundingSphere&&(s.boundingSphere=o.boundingSphere.clone()),null!==o.boundingBox&&(s.boundingBox=o.boundingBox.clone())}else t.isMesh&&(s=o.toBufferGeometry());return s};class n{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,o,r;const n=e.faces;for(o=0;o<n.length;o++){const e=n[o];e.materialIndex!==r&&(r=e.materialIndex,void 0!==s&&(s.count=3*o-s.start,t.push(s)),s={start:3*o,materialIndex:r})}void 0!==s&&(s.count=3*o-s.start,t.push(s)),this.groups=t}fromGeometry(t){const s=t.faces,o=t.vertices,r=t.faceVertexUvs,n=r[0]&&r[0].length>0,i=r[1]&&r[1].length>0,l=t.morphTargets,a=l.length;let c;if(a>0){c=[];for(let e=0;e<a;e++)c[e]={name:l[e].name,data:[]};this.morphTargets.position=c}const h=t.morphNormals,u=h.length;let p;if(u>0){p=[];for(let e=0;e<u;e++)p[e]={name:h[e].name,data:[]};this.morphTargets.normal=p}const m=t.skinIndices,f=t.skinWeights,d=m.length===o.length,g=f.length===o.length;o.length>0&&0===s.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let t=0;t<s.length;t++){const v=s[t];this.vertices.push(o[v.a],o[v.b],o[v.c]);const x=v.vertexNormals;if(3===x.length)this.normals.push(x[0],x[1],x[2]);else{const e=v.normal;this.normals.push(e,e,e)}const y=v.vertexColors;if(3===y.length)this.colors.push(y[0],y[1],y[2]);else{const e=v.color;this.colors.push(e,e,e)}if(!0===n){const s=r[0][t];void 0!==s?this.uvs.push(s[0],s[1],s[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",t),this.uvs.push(new e.Vector2,new e.Vector2,new e.Vector2))}if(!0===i){const s=r[1][t];void 0!==s?this.uvs2.push(s[0],s[1],s[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",t),this.uvs2.push(new e.Vector2,new e.Vector2,new e.Vector2))}for(let e=0;e<a;e++){const t=l[e].vertices;c[e].data.push(t[v.a],t[v.b],t[v.c])}for(let e=0;e<u;e++){const s=h[e].vertexNormals[t];p[e].data.push(s.a,s.b,s.c)}d&&this.skinIndices.push(m[v.a],m[v.b],m[v.c]),g&&this.skinWeights.push(f[v.a],f[v.b],f[v.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this}}class i{constructor(t,s,o,r,n,i=0){this.a=t,this.b=s,this.c=o,this.normal=r&&r.isVector3?r:new e.Vector3,this.vertexNormals=Array.isArray(r)?r:[],this.color=n&&n.isColor?n:new e.Color,this.vertexColors=Array.isArray(n)?n:[],this.materialIndex=i}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}exports.Face3=i,exports.Geometry=r;
