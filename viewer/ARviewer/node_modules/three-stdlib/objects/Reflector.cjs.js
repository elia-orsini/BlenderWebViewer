"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");class t extends e.Mesh{constructor(r,n={}){super(r),this.type="Reflector";const a=this,o=void 0!==n.color?new e.Color(n.color):new e.Color(8355711),l=n.textureWidth||512,i=n.textureHeight||512,s=n.clipBias||0,d=n.shader||t.ReflectorShader,c=new e.Plane,u=new e.Vector3,p=new e.Vector3,m=new e.Vector3,x=new e.Matrix4,v=new e.Vector3(0,0,-1),f=new e.Vector4,b=new e.Vector3,g=new e.Vector3,h=new e.Vector4,M=new e.Matrix4,y=new e.PerspectiveCamera,w=new e.WebGLRenderTarget(l,i),R=new e.ShaderMaterial({uniforms:e.UniformsUtils.clone(d.uniforms),fragmentShader:d.fragmentShader,vertexShader:d.vertexShader});R.uniforms.tDiffuse.value=w.texture,R.uniforms.color.value=o,R.uniforms.textureMatrix.value=M,this.material=R,this.onBeforeRender=function(e,t,r){if(p.setFromMatrixPosition(a.matrixWorld),m.setFromMatrixPosition(r.matrixWorld),x.extractRotation(a.matrixWorld),u.set(0,0,1),u.applyMatrix4(x),b.subVectors(p,m),b.dot(u)>0)return;b.reflect(u).negate(),b.add(p),x.extractRotation(r.matrixWorld),v.set(0,0,-1),v.applyMatrix4(x),v.add(m),g.subVectors(p,v),g.reflect(u).negate(),g.add(p),y.position.copy(b),y.up.set(0,1,0),y.up.applyMatrix4(x),y.up.reflect(u),y.lookAt(g),y.far=r.far,y.updateMatrixWorld(),y.projectionMatrix.copy(r.projectionMatrix),M.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),M.multiply(y.projectionMatrix),M.multiply(y.matrixWorldInverse),M.multiply(a.matrixWorld),c.setFromNormalAndCoplanarPoint(u,p),c.applyMatrix4(y.matrixWorldInverse),f.set(c.normal.x,c.normal.y,c.normal.z,c.constant);const n=y.projectionMatrix;h.x=(Math.sign(f.x)+n.elements[8])/n.elements[0],h.y=(Math.sign(f.y)+n.elements[9])/n.elements[5],h.z=-1,h.w=(1+n.elements[10])/n.elements[14],f.multiplyScalar(2/f.dot(h)),n.elements[2]=f.x,n.elements[6]=f.y,n.elements[10]=f.z+1-s,n.elements[14]=f.w,w.texture.encoding=e.outputEncoding,a.visible=!1;const o=e.getRenderTarget(),l=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(w),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,y),e.xr.enabled=l,e.shadowMap.autoUpdate=i,e.setRenderTarget(o);const d=r.viewport;void 0!==d&&e.state.viewport(d),a.visible=!0},this.getRenderTarget=function(){return w},this.dispose=function(){w.dispose(),a.material.dispose()}}}t.prototype.isReflector=!0,t.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},exports.Reflector=t;
