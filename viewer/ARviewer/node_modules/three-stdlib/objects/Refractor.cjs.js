"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");class t extends e.Mesh{constructor(r,n={}){super(r),this.type="Refractor";const o=this,a=void 0!==n.color?new e.Color(n.color):new e.Color(8355711),i=n.textureWidth||512,l=n.textureHeight||512,s=n.clipBias||0,c=n.shader||t.RefractorShader,u=new e.PerspectiveCamera;u.matrixAutoUpdate=!1,u.userData.refractor=!0;const d=new e.Plane,m=new e.Matrix4,v=new e.WebGLRenderTarget(i,l);this.material=new e.ShaderMaterial({uniforms:e.UniformsUtils.clone(c.uniforms),vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,transparent:!0}),this.material.uniforms.color.value=a,this.material.uniforms.tDiffuse.value=v.texture,this.material.uniforms.textureMatrix.value=m;const x=function(){const t=new e.Vector3,r=new e.Vector3,n=new e.Matrix4,a=new e.Vector3,i=new e.Vector3;return function(e){return t.setFromMatrixPosition(o.matrixWorld),r.setFromMatrixPosition(e.matrixWorld),a.subVectors(t,r),n.extractRotation(o.matrixWorld),i.set(0,0,1),i.applyMatrix4(n),a.dot(i)<0}}(),p=function(){const t=new e.Vector3,r=new e.Vector3,n=new e.Quaternion,a=new e.Vector3;return function(){o.matrixWorld.decompose(r,n,a),t.set(0,0,1).applyQuaternion(n).normalize(),t.negate(),d.setFromNormalAndCoplanarPoint(t,r)}}(),f=function(){const t=new e.Plane,r=new e.Vector4,n=new e.Vector4;return function(e){u.matrixWorld.copy(e.matrixWorld),u.matrixWorldInverse.copy(u.matrixWorld).invert(),u.projectionMatrix.copy(e.projectionMatrix),u.far=e.far,t.copy(d),t.applyMatrix4(u.matrixWorldInverse),r.set(t.normal.x,t.normal.y,t.normal.z,t.constant);const o=u.projectionMatrix;n.x=(Math.sign(r.x)+o.elements[8])/o.elements[0],n.y=(Math.sign(r.y)+o.elements[9])/o.elements[5],n.z=-1,n.w=(1+o.elements[10])/o.elements[14],r.multiplyScalar(2/r.dot(n)),o.elements[2]=r.x,o.elements[6]=r.y,o.elements[10]=r.z+1-s,o.elements[14]=r.w}}();this.onBeforeRender=function(e,t,r){v.texture.encoding=e.outputEncoding,!0!==r.userData.refractor&&!0!=!x(r)&&(p(),function(e){m.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),m.multiply(e.projectionMatrix),m.multiply(e.matrixWorldInverse),m.multiply(o.matrixWorld)}(r),f(r),function(e,t,r){o.visible=!1;const n=e.getRenderTarget(),a=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(v),!1===e.autoClear&&e.clear(),e.render(t,u),e.xr.enabled=a,e.shadowMap.autoUpdate=i,e.setRenderTarget(n);const l=r.viewport;void 0!==l&&e.state.viewport(l),o.visible=!0}(e,t,r))},this.getRenderTarget=function(){return v},this.dispose=function(){v.dispose(),o.material.dispose()}}}t.prototype.isRefractor=!0,t.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},exports.Refractor=t;
