"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/defineProperty"),t=require("three");function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=n(e);const s=(e=1)=>{const n=new Float32Array(4096*e*4),r=new t.DataTexture(n,1024,4*e,t.RGBAFormat,t.FloatType);return r.wrapS=t.RepeatWrapping,r.wrapT=t.RepeatWrapping,r.magFilter=t.NearestFilter,r.needsUpdate=!0,r},i=(e,t,n=0)=>{const r=Math.floor(1024);t.arcLengthDivisions=r/2,t.updateArcLengths();const s=t.getSpacedPoints(r),i=t.computeFrenetFrames(r,!0);for(let t=0;t<r;t++){const r=Math.floor(t/1024),o=t%1024;let f=s[t];a(e,o,f.x,f.y,f.z,0+r+4*n),f=i.tangents[t],a(e,o,f.x,f.y,f.z,1+r+4*n),f=i.normals[t],a(e,o,f.x,f.y,f.z,2+r+4*n),f=i.binormals[t],a(e,o,f.x,f.y,f.z,3+r+4*n)}e.needsUpdate=!0},a=(e,t,n,r,s,i)=>{const a=e.image,{data:o}=a,f=4096*i;o[4*t+f+0]=n,o[4*t+f+1]=r,o[4*t+f+2]=s,o[4*t+f+3]=1},o=e=>({spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}});function f(e,t,n=1){e.__ok||(e.__ok=!0,e.onBeforeCompile=e=>{if(e.__modified)return;e.__modified=!0,Object.assign(e.uniforms,t);const r=`\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${4*n}.;\n\t\tfloat textureStacks = 1.;\n\n\t\t${e.vertexShader}\n\t\t`.replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,"\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * 4.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t").replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=r})}class l{constructor(e,n=1){r.default(this,"curveArray",void 0),r.default(this,"curveLengthArray",void 0),r.default(this,"object3D",void 0),r.default(this,"splineTexure",void 0),r.default(this,"uniforms",void 0);const i=e.clone(),a=s(n),l=o(a);i.traverse((e=>{(e instanceof t.Mesh||e instanceof t.InstancedMesh)&&(e.material=e.material.clone(),f(e.material,l,n))})),this.curveArray=new Array(n),this.curveLengthArray=new Array(n),this.object3D=i,this.splineTexure=a,this.uniforms=l}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");const n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,i(this.splineTexure,t,e)}moveAlongCurve(e){this.uniforms.pathOffset.value+=e}}const u=new t.Matrix4;exports.Flow=l,exports.InstancedFlow=class extends l{constructor(e,n,s,i){const a=new t.InstancedMesh(s,i,e);a.instanceMatrix.setUsage(t.DynamicDrawUsage),super(a,n),r.default(this,"offsets",void 0),r.default(this,"whichCurve",void 0),this.offsets=new Array(e).fill(0),this.whichCurve=new Array(e).fill(0)}writeChanges(e){u.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,u),this.object3D.instanceMatrix.needsUpdate=!0}moveIndividualAlongCurve(e,t){this.offsets[e]+=t,this.writeChanges(e)}setCurve(e,t){if(isNaN(t))throw Error("curve index being set is Not a Number (NaN)");this.whichCurve[e]=t,this.writeChanges(e)}},exports.getUniforms=o,exports.initSplineTexture=s,exports.modifyShader=f,exports.updateSplineTexture=i;
