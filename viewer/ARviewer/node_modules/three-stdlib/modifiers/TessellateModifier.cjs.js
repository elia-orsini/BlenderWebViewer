"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("@babel/runtime/helpers/defineProperty"),e=require("three");function t(r){return r&&"object"==typeof r&&"default"in r?r:{default:r}}var o=t(r);exports.TessellateModifier=class{constructor(r=.1,t=6){o.default(this,"maxEdgeLength",void 0),o.default(this,"maxIterations",void 0),o.default(this,"modify",(r=>{null!==r.index&&(r=r.toNonIndexed());const t=this.maxIterations,o=this.maxEdgeLength*this.maxEdgeLength,s=new e.Vector3,n=new e.Vector3,u=new e.Vector3,a=new e.Vector3,l=[s,n,u,a],i=new e.Vector3,c=new e.Vector3,f=new e.Vector3,p=new e.Vector3,y=[i,c,f,p],h=new e.Color,d=new e.Color,m=new e.Color,V=new e.Color,w=[h,d,m,V],A=new e.Vector2,x=new e.Vector2,b=new e.Vector2,v=new e.Vector2,g=[A,x,b,v],C=new e.Vector2,z=new e.Vector2,B=new e.Vector2,q=new e.Vector2,F=[C,z,B,q],E=r.attributes,I=void 0!==E.normal,L=void 0!==E.color,T=void 0!==E.uv,S=void 0!==E.uv2;let j=E.position.array,M=I?E.normal.array:null,P=L?E.color.array:null,_=T?E.uv.array:null,G=S?E.uv2.array:null,N=j,O=M,k=P,D=_,H=G,J=0,K=!0;function Q(r,e,t){const o=l[r],s=l[e],n=l[t];if(N.push(o.x,o.y,o.z),N.push(s.x,s.y,s.z),N.push(n.x,n.y,n.z),I){const o=y[r],s=y[e],n=y[t];O.push(o.x,o.y,o.z),O.push(s.x,s.y,s.z),O.push(n.x,n.y,n.z)}if(L){const o=w[r],s=w[e],n=w[t];k.push(o.r,o.g,o.b),k.push(s.r,s.g,s.b),k.push(n.r,n.g,n.b)}if(T){const o=g[r],s=g[e],n=g[t];D.push(o.x,o.y),D.push(s.x,s.y),D.push(n.x,n.y)}if(S){const o=F[r],s=F[e],n=F[t];H.push(o.x,o.y),H.push(s.x,s.y),H.push(n.x,n.y)}}for(;K&&J<t;){J++,K=!1,j=N,N=[],I&&(M=O,O=[]),L&&(P=k,k=[]),T&&(_=D,D=[]),S&&(G=H,H=[]);for(let r=0,e=0,t=j.length;r<t;r+=9,e+=6){s.fromArray(j,r+0),n.fromArray(j,r+3),u.fromArray(j,r+6),I&&M&&(i.fromArray(M,r+0),c.fromArray(M,r+3),f.fromArray(M,r+6)),L&&P&&(h.fromArray(P,r+0),d.fromArray(P,r+3),m.fromArray(P,r+6)),T&&_&&(A.fromArray(_,e+0),x.fromArray(_,e+2),b.fromArray(_,e+4)),S&&G&&(C.fromArray(G,e+0),z.fromArray(G,e+2),B.fromArray(G,e+4));const t=s.distanceToSquared(n),l=n.distanceToSquared(u),y=s.distanceToSquared(u);t>o||l>o||y>o?(K=!0,t>=l&&t>=y?(a.lerpVectors(s,n,.5),I&&p.lerpVectors(i,c,.5),L&&V.lerpColors(h,d,.5),T&&v.lerpVectors(A,x,.5),S&&q.lerpVectors(C,z,.5),Q(0,3,2),Q(3,1,2)):l>=t&&l>=y?(a.lerpVectors(n,u,.5),I&&p.lerpVectors(c,f,.5),L&&V.lerpColors(d,m,.5),T&&v.lerpVectors(x,b,.5),S&&q.lerpVectors(z,B,.5),Q(0,1,3),Q(3,2,0)):(a.lerpVectors(s,u,.5),I&&p.lerpVectors(i,f,.5),L&&V.lerpColors(h,m,.5),T&&v.lerpVectors(A,b,.5),S&&q.lerpVectors(C,B,.5),Q(0,1,3),Q(3,1,2))):Q(0,1,2)}}const R=new e.BufferGeometry;return R.setAttribute("position",new e.Float32BufferAttribute(N,3)),I&&R.setAttribute("normal",new e.Float32BufferAttribute(O,3)),L&&R.setAttribute("color",new e.Float32BufferAttribute(k,3)),T&&R.setAttribute("uv",new e.Float32BufferAttribute(D,2)),S&&R.setAttribute("uv2",new e.Float32BufferAttribute(H,2)),R})),this.maxEdgeLength=r,this.maxIterations=t}};
