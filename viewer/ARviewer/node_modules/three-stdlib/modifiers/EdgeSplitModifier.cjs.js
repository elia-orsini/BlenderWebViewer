"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),e=require("three"),s=require("../BufferGeometryUtils-971dfde3.js");function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}require("../types/helpers.cjs.js");var o=i(t);exports.EdgeSplitModifier=class{constructor(){o.default(this,"A",new e.Vector3),o.default(this,"B",new e.Vector3),o.default(this,"C",new e.Vector3),o.default(this,"positions",[]),o.default(this,"normals",new Float32Array),o.default(this,"indexes",[]),o.default(this,"pointToIndexMap",[]),o.default(this,"splitIndexes",[]),o.default(this,"oldNormals",[]),o.default(this,"computeNormals",(()=>{this.normals=new Float32Array(3*this.indexes.length);for(let t=0;t<this.indexes.length;t+=3){let e=this.indexes[t];this.A.set(this.positions[3*e],this.positions[3*e+1],this.positions[3*e+2]),e=this.indexes[t+1],this.B.set(this.positions[3*e],this.positions[3*e+1],this.positions[3*e+2]),e=this.indexes[t+2],this.C.set(this.positions[3*e],this.positions[3*e+1],this.positions[3*e+2]),this.C.sub(this.B),this.A.sub(this.B);const s=this.C.cross(this.A).normalize();for(let e=0;e<3;e++)this.normals[3*(t+e)]=s.x,this.normals[3*(t+e)+1]=s.y,this.normals[3*(t+e)+2]=s.z}})),o.default(this,"mapPositionsToIndexes",(()=>{this.pointToIndexMap=Array(this.positions.length/3);for(let t=0;t<this.indexes.length;t++){const e=this.indexes[t];null==this.pointToIndexMap[e]&&(this.pointToIndexMap[e]=[]),this.pointToIndexMap[e].push(t)}})),o.default(this,"edgeSplitToGroups",((t,e,s)=>{this.A.set(this.normals[3*s],this.normals[3*s+1],this.normals[3*s+2]).normalize();const i={splitGroup:[],currentGroup:[s]};for(let o of t)o!==s&&(this.B.set(this.normals[3*o],this.normals[3*o+1],this.normals[3*o+2]).normalize(),this.B.dot(this.A)<e?i.splitGroup.push(o):i.currentGroup.push(o));return i})),o.default(this,"edgeSplit",((t,e,s=null)=>{if(0===t.length)return;const i=[];for(let s of t)i.push(this.edgeSplitToGroups(t,e,s));let o=i[0];for(let t of i)t.currentGroup.length>o.currentGroup.length&&(o=t);null!=s&&this.splitIndexes.push({original:s,indexes:o.currentGroup}),o.splitGroup.length&&this.edgeSplit(o.splitGroup,e,s||o.currentGroup[0])})),o.default(this,"modify",((t,i,o=!0)=>{let r=!1;if(t.attributes.normal&&(r=!0,t=t.clone(),!0===o&&null!==t.index&&(this.oldNormals=t.attributes.normal.array),t.deleteAttribute("normal")),null==t.index){if(void 0===s.BufferGeometryUtils)throw"THREE.EdgeSplitModifier relies on BufferGeometryUtils";t=s.mergeVertices(t)}this.indexes=t.index.array,this.positions=t.getAttribute("position").array,this.computeNormals(),this.mapPositionsToIndexes(),this.splitIndexes=[];for(let t of this.pointToIndexMap)this.edgeSplit(t,Math.cos(i)-.001);const n={};for(let s of Object.keys(t.attributes)){const i=t.attributes[s],o=new i.array.constructor((this.indexes.length+this.splitIndexes.length)*i.itemSize);o.set(i.array),n[s]=new e.BufferAttribute(o,i.itemSize,i.normalized)}const l=new Uint32Array(this.indexes.length);l.set(this.indexes);for(let t=0;t<this.splitIndexes.length;t++){const e=this.splitIndexes[t],s=this.indexes[e.original];for(let e of Object.values(n))for(let i=0;i<e.itemSize;i++)e.array[(this.indexes.length+t)*e.itemSize+i]=e.array[s*e.itemSize+i];for(let s of e.indexes)l[s]=this.indexes.length+t}(t=new e.BufferGeometry).setIndex(new e.BufferAttribute(l,1));for(let e of Object.keys(n))t.setAttribute(e,n[e]);if(r&&(t.computeVertexNormals(),null!==this.oldNormals)){const e=new Array(this.oldNormals.length/3).fill(!1);for(let t of this.splitIndexes)e[t.original]=!0;for(let s=0;s<e.length;s++)if(!1===e[s])for(let e=0;e<3;e++)t.attributes.normal.array[3*s+e]=this.oldNormals[3*s+e]}return t}))}};
