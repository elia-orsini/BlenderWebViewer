"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");const e=new t.Vector3,n=new t.Line3,s=new t.Plane,i=new t.Vector3,r=new t.Triangle;class o{constructor(){this.normal=new t.Vector3,this.midpoint=new t.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,n){const s=new o,i=new a(t,s),r=new a(e,s),l=new a(n,s);return i.next=l.prev=r,r.next=i.prev=l,l.next=r.prev=i,s.edge=i,s.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return r.set(t.point,e.point,n.point),r.getNormal(this.normal),r.getMidpoint(this.midpoint),this.area=r.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class a{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class l{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class h{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}exports.ConvexHull=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new h,this.unassigned=new h,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new l(t[e]));this.compute()}return this}setFromObject(e){const n=[];return e.updateMatrixWorld(!0),e.traverse((function(e){const s=e.geometry;if(void 0!==s){if(s.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(s.isBufferGeometry){const i=s.attributes.position;if(void 0!==i)for(let s=0,r=i.count;s<r;s++){const r=new t.Vector3;r.fromBufferAttribute(i,s).applyMatrix4(e.matrixWorld),n.push(r)}}}})),this.setFromPoints(n)}containsPoint(t){const e=this.faces;for(let n=0,s=e.length;n<s;n++){if(e[n].distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const n=this.faces;let s=-1/0,i=1/0;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.distanceToPoint(t.origin),a=r.normal.dot(t.direction);if(o>0&&a>=0)return null;const l=0!==a?-o/a:0;if(!(l<=0)&&(a>0?i=Math.min(l,i):s=Math.max(l,s),s>i))return null}return s!==-1/0?t.at(s,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,e)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const n=e.next;let s=this.tolerance,i=null;for(let n=0;n<t.length;n++){const r=t[n];if(0===r.mark){const t=r.distanceToPoint(e.point);if(t>s&&(s=t,i=r),s>1e3*this.tolerance)break}}null!==i&&this.addVertexToFace(e,i),e=n}while(null!==e)}return this}computeExtremes(){const e=new t.Vector3,n=new t.Vector3,s=[],i=[];for(let t=0;t<3;t++)s[t]=i[t]=this.vertices[0];e.copy(this.vertices[0].point),n.copy(this.vertices[0].point);for(let t=0,r=this.vertices.length;t<r;t++){const r=this.vertices[t],o=r.point;for(let t=0;t<3;t++)o.getComponent(t)<e.getComponent(t)&&(e.setComponent(t,o.getComponent(t)),s[t]=r);for(let t=0;t<3;t++)o.getComponent(t)>n.getComponent(t)&&(n.setComponent(t,o.getComponent(t)),i[t]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(n.x))+Math.max(Math.abs(e.y),Math.abs(n.y))+Math.max(Math.abs(e.z),Math.abs(n.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),r=e.min,a=e.max;let l=0,h=0;for(let t=0;t<3;t++){const e=a[t].point.getComponent(t)-r[t].point.getComponent(t);e>l&&(l=e,h=t)}const c=r[h],u=a[h];let d,p;l=0,n.set(c.point,u.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==c&&s!==u){n.closestPointToPoint(s.point,!0,i);const t=i.distanceToSquared(s.point);t>l&&(l=t,d=s)}}l=-1,s.setFromCoplanarPoints(c.point,u.point,d.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==c&&n!==u&&n!==d){const t=Math.abs(s.distanceToPoint(n.point));t>l&&(l=t,p=n)}}const f=[];if(s.distanceToPoint(p.point)<0){f.push(o.create(c,u,d),o.create(p,u,c),o.create(p,d,u),o.create(p,c,d));for(let t=0;t<3;t++){const e=(t+1)%3;f[t+1].getEdge(2).setTwin(f[0].getEdge(e)),f[t+1].getEdge(1).setTwin(f[e+1].getEdge(0))}}else{f.push(o.create(c,d,u),o.create(p,c,u),o.create(p,u,d),o.create(p,d,c));for(let t=0;t<3;t++){const e=(t+1)%3;f[t+1].getEdge(2).setTwin(f[0].getEdge((3-t)%3)),f[t+1].getEdge(0).setTwin(f[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(f[t]);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n!==c&&n!==u&&n!==d&&n!==p){l=this.tolerance;let t=null;for(let e=0;e<4;e++){const s=this.faces[e].distanceToPoint(n.point);s>l&&(l=s,t=this.faces[e])}null!==t&&this.addVertexToFace(n,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];0===n.mark&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let s=n.outside;do{const i=n.distanceToPoint(s.point);i>e&&(e=i,t=s),s=s.next}while(null!==s&&s.face===n);return t}}computeHorizon(t,e,n,s){let i;this.deleteFaceVertices(n),n.mark=1,i=null===e?e=n.getEdge(0):e.next;do{const e=i.twin,n=e.face;0===n.mark&&(n.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,n,s):s.push(i)),i=i.next}while(i!==e);return this}addAdjoiningFace(t,e){const n=o.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,s=null;for(let i=0;i<e.length;i++){const r=e[i],o=this.addAdjoiningFace(t,r);null===n?n=o:o.next.setTwin(s),this.newFaces.push(o.face),s=o}return n.next.setTwin(s),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}};
