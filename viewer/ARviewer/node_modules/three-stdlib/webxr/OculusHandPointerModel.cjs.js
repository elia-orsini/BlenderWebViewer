"use strict";function t(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var s=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,s.get?s:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}Object.defineProperty(exports,"__esModule",{value:!0});var e=t(require("three"));const i=new e.Vector3(0,1,0),s=new e.Vector3(0,0,1);class r extends e.Object3D{constructor(t,e){super(),this.hand=t,this.controller=e,this.motionController=null,this.envMap=null,this.mesh=null,this.pointerGeometry=null,this.pointerMesh=null,this.pointerObject=null,this.pinched=!1,this.attached=!1,this.cursorObject=null,this.raycaster=null,t.addEventListener("connected",(t=>{const e=t.data;e.hand&&(this.visible=!0,this.xrInputSource=e,this.createPointer())}))}_drawVerticesRing(t,e,i){const r=e.clone();for(var o=0;o<16;o++){r.applyAxisAngle(s,2*Math.PI/16);const e=16*i+o;t[3*e]=r.x,t[3*e+1]=r.y,t[3*e+2]=r.z}}_updatePointerVertices(t){const s=this.pointerGeometry.attributes.position.array,r=new e.Vector3(.002,0,-1*(.035-t));this._drawVerticesRing(s,r,0);const o=new e.Vector3(Math.sin(110*Math.PI/180)*t,Math.cos(110*Math.PI/180)*t,0);for(var n=0;n<12;n++)this._drawVerticesRing(s,o,n+1),o.applyAxisAngle(i,110*Math.PI/180/-24);const a=new e.Vector3(0,0,-1*(.035-t));s[624]=a.x,s[625]=a.y,s[626]=a.z;const c=new e.Vector3(0,0,t);s[627]=c.x,s[628]=c.y,s[629]=c.z,this.pointerGeometry.setAttribute("position",new e.Float32BufferAttribute(s,3))}createPointer(){var t,i;const s=new Array(630).fill(0),r=[];for(this.pointerGeometry=new e.BufferGeometry,this.pointerGeometry.setAttribute("position",new e.Float32BufferAttribute(s,3)),this._updatePointerVertices(.01),t=0;t<12;t++){for(i=0;i<15;i++)r.push(16*t+i,16*t+i+1,16*(t+1)+i),r.push(16*t+i+1,16*(t+1)+i+1,16*(t+1)+i);r.push(16*(t+1)-1,16*t,16*(t+2)-1),r.push(16*t,16*(t+1),16*(t+2)-1)}for(t=0;t<15;t++)r.push(208,t+1,t),r.push(209,t+192,t+192+1);r.push(208,0,15),r.push(209,207,192);const o=new e.MeshBasicMaterial;o.transparent=!0,o.opacity=.4,this.pointerGeometry.setIndex(r),this.pointerMesh=new e.Mesh(this.pointerGeometry,o),this.pointerMesh.position.set(0,0,-.01),this.pointerObject=new e.Object3D,this.pointerObject.add(this.pointerMesh),this.raycaster=new e.Raycaster;const n=new e.SphereGeometry(.02,10,10),a=new e.MeshBasicMaterial;a.transparent=!0,a.opacity=.4,this.cursorObject=new e.Mesh(n,a),this.pointerObject.add(this.cursorObject),this.add(this.pointerObject)}_updateRaycaster(){if(this.raycaster){const t=this.pointerObject.matrixWorld,i=new e.Matrix4;i.identity().extractRotation(t),this.raycaster.ray.origin.setFromMatrixPosition(t),this.raycaster.ray.direction.set(0,0,-1).applyMatrix4(i)}}_updatePointer(){this.pointerObject.visible=this.controller.visible;const t=this.hand.joints["index-finger-tip"],e=this.hand.joints["thumb-tip"],i=t.position.distanceTo(e.position),s=t.position.clone().add(e.position).multiplyScalar(.5);this.pointerObject.position.copy(s),this.pointerObject.quaternion.copy(this.controller.quaternion),this.pinched=i<=.02;const r=(i-.01)/.04,o=(i-.01)/.01;if(r>1)this._updatePointerVertices(.01),this.pointerMesh.position.set(0,0,-.01),this.pointerMesh.material.opacity=.4;else if(r>0){const t=.007*r+.003;this._updatePointerVertices(t),o<1?(this.pointerMesh.position.set(0,0,-1*t-.02*(1-o)),this.pointerMesh.material.opacity=.4+.6*(1-o)):(this.pointerMesh.position.set(0,0,-1*t),this.pointerMesh.material.opacity=.4)}else this._updatePointerVertices(.003),this.pointerMesh.position.set(0,0,-.023),this.pointerMesh.material.opacity=1;this.cursorObject.material.opacity=this.pointerMesh.material.opacity}updateMatrixWorld(t){super.updateMatrixWorld(t),this.pointerGeometry&&(this._updatePointer(),this._updateRaycaster())}isPinched(){return this.pinched}setAttached(t){this.attached=t}isAttached(){return this.attached}intersectObject(t,e=!0){if(this.raycaster)return this.raycaster.intersectObject(t,e)}intersectObjects(t,e=!0){if(this.raycaster)return this.raycaster.intersectObjects(t,e)}checkIntersections(t,i=!1){if(this.raycaster&&!this.attached){const s=this.raycaster.intersectObjects(t,i),r=new e.Vector3(0,0,-1);if(s.length>0){const t=s[0].distance;this.cursorObject.position.copy(r.multiplyScalar(t))}else this.cursorObject.position.copy(r.multiplyScalar(1.5))}}setCursor(t){const i=new e.Vector3(0,0,-1);this.raycaster&&!this.attached&&this.cursorObject.position.copy(i.multiplyScalar(t))}}exports.OculusHandPointerModel=r;
