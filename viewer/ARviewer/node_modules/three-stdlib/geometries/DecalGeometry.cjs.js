"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");class o extends t.BufferGeometry{constructor(o,n,s,r){super();const i=[],u=[],p=[],l=new t.Vector3,c=new t.Matrix4;c.makeRotationFromEuler(s),c.setPosition(n);const a=new t.Matrix4;function h(t,n,s){n.applyMatrix4(o.matrixWorld),n.applyMatrix4(a),s.transformDirection(o.matrixWorld),t.push(new e(n.clone(),s.clone()))}function f(t,o){const e=[],n=.5*Math.abs(r.dot(o));for(let s=0;s<t.length;s+=3){let r,i,u,p,l,c,a,h=0;const f=t[s+0].position.dot(o)-n,x=t[s+1].position.dot(o)-n,y=t[s+2].position.dot(o)-n;switch(r=f>0,i=x>0,u=y>0,h=(r?1:0)+(i?1:0)+(u?1:0),h){case 0:e.push(t[s]),e.push(t[s+1]),e.push(t[s+2]);break;case 1:if(r&&(p=t[s+1],l=t[s+2],c=m(t[s],p,o,n),a=m(t[s],l,o,n)),i){p=t[s],l=t[s+2],c=m(t[s+1],p,o,n),a=m(t[s+1],l,o,n),e.push(c),e.push(l.clone()),e.push(p.clone()),e.push(l.clone()),e.push(c.clone()),e.push(a);break}u&&(p=t[s],l=t[s+1],c=m(t[s+2],p,o,n),a=m(t[s+2],l,o,n)),e.push(p.clone()),e.push(l.clone()),e.push(c),e.push(a),e.push(c.clone()),e.push(l.clone());break;case 2:r||(p=t[s].clone(),l=m(p,t[s+1],o,n),c=m(p,t[s+2],o,n),e.push(p),e.push(l),e.push(c)),i||(p=t[s+1].clone(),l=m(p,t[s+2],o,n),c=m(p,t[s],o,n),e.push(p),e.push(l),e.push(c)),u||(p=t[s+2].clone(),l=m(p,t[s],o,n),c=m(p,t[s+1],o,n),e.push(p),e.push(l),e.push(c))}}return e}function m(o,n,s,r){const i=o.position.dot(s)-r,u=i/(i-(n.position.dot(s)-r));return new e(new t.Vector3(o.position.x+u*(n.position.x-o.position.x),o.position.y+u*(n.position.y-o.position.y),o.position.z+u*(n.position.z-o.position.z)),new t.Vector3(o.normal.x+u*(n.normal.x-o.normal.x),o.normal.y+u*(n.normal.y-o.normal.y),o.normal.z+u*(n.normal.z-o.normal.z)))}a.copy(c).invert(),function(){let e,n=[];const s=new t.Vector3,a=new t.Vector3;if(!0===o.geometry.isGeometry)return void console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");const m=o.geometry,x=m.attributes.position,y=m.attributes.normal;if(null!==m.index){const t=m.index;for(e=0;e<t.count;e++)s.fromBufferAttribute(x,t.getX(e)),a.fromBufferAttribute(y,t.getX(e)),h(n,s,a)}else for(e=0;e<x.count;e++)s.fromBufferAttribute(x,e),a.fromBufferAttribute(y,e),h(n,s,a);for(n=f(n,l.set(1,0,0)),n=f(n,l.set(-1,0,0)),n=f(n,l.set(0,1,0)),n=f(n,l.set(0,-1,0)),n=f(n,l.set(0,0,1)),n=f(n,l.set(0,0,-1)),e=0;e<n.length;e++){const t=n[e];p.push(.5+t.position.x/r.x,.5+t.position.y/r.y),t.position.applyMatrix4(c),i.push(t.position.x,t.position.y,t.position.z),u.push(t.normal.x,t.normal.y,t.normal.z)}}(),this.setAttribute("position",new t.Float32BufferAttribute(i,3)),this.setAttribute("normal",new t.Float32BufferAttribute(u,3)),this.setAttribute("uv",new t.Float32BufferAttribute(p,2))}}class e{constructor(t,o){this.position=t,this.normal=o}clone(){return new this.constructor(this.position.clone(),this.normal.clone())}}exports.DecalGeometry=o,exports.DecalVertex=e;
