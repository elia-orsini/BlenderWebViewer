"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");class t extends e.Loader{constructor(e){super(e),this.propertyNameMapping={}}load(t,n,s,r){const i=this,o=new e.FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(function(e){try{n(i.parse(e))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),s,r)}setPropertyNameMapping(e){this.propertyNameMapping=e}parse(t){function n(e){let t="",n=0;const s=/ply([\s\S]*)end_header\r?\n/.exec(e);null!==s&&(t=s[1],n=new Blob([s[0]]).size);const r={comments:[],elements:[],headerLength:n,objInfo:""},i=t.split("\n");let o;function a(e,t){const n={type:e[0]};return"list"===n.type?(n.name=e[3],n.countType=e[1],n.itemType=e[2]):n.name=e[1],n.name in t&&(n.name=t[n.name]),n}for(let e=0;e<i.length;e++){let t=i[e];if(t=t.trim(),""===t)continue;const n=t.split(/\s+/),s=n.shift();switch(t=n.join(" "),s){case"format":r.format=n[0],r.version=n[1];break;case"comment":r.comments.push(t);break;case"element":void 0!==o&&r.elements.push(o),o={},o.name=n[0],o.count=parseInt(n[1]),o.properties=[];break;case"property":o.properties.push(a(n,p.propertyNameMapping));break;case"obj_info":r.objInfo=t;break;default:console.log("unhandled",s,n)}}return void 0!==o&&r.elements.push(o),r}function s(e,t){switch(t){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(e);case"float":case"double":case"float32":case"float64":return parseFloat(e)}}function r(e,t){const n=t.split(/\s+/),r={};for(let t=0;t<e.length;t++)if("list"===e[t].type){const i=[],o=s(n.shift(),e[t].countType);for(let r=0;r<o;r++)i.push(s(n.shift(),e[t].itemType));r[e[t].name]=i}else r[e[t].name]=s(n.shift(),e[t].type);return r}function i(e,t){const n={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]};let s;let i="";null!==(s=/end_header\s([\s\S]*)$/.exec(e))&&(i=s[1]);const c=i.split("\n");let u=0,l=0;for(let e=0;e<c.length;e++){let s=c[e];if(s=s.trim(),""===s)continue;l>=t.elements[u].count&&(u++,l=0);const i=r(t.elements[u].properties,s);a(n,t.elements[u].name,i),l++}return o(n)}function o(t){let n=new e.BufferGeometry;return t.indices.length>0&&n.setIndex(t.indices),n.setAttribute("position",new e.Float32BufferAttribute(t.vertices,3)),t.normals.length>0&&n.setAttribute("normal",new e.Float32BufferAttribute(t.normals,3)),t.uvs.length>0&&n.setAttribute("uv",new e.Float32BufferAttribute(t.uvs,2)),t.colors.length>0&&n.setAttribute("color",new e.Float32BufferAttribute(t.colors,3)),t.faceVertexUvs.length>0&&(n=n.toNonIndexed(),n.setAttribute("uv",new e.Float32BufferAttribute(t.faceVertexUvs,2))),n.computeBoundingSphere(),n}function a(e,t,n){if("vertex"===t)e.vertices.push(n.x,n.y,n.z),"nx"in n&&"ny"in n&&"nz"in n&&e.normals.push(n.nx,n.ny,n.nz),"s"in n&&"t"in n&&e.uvs.push(n.s,n.t),"red"in n&&"green"in n&&"blue"in n&&e.colors.push(n.red/255,n.green/255,n.blue/255);else if("face"===t){const t=n.vertex_indices||n.vertex_index,s=n.texcoord;3===t.length?(e.indices.push(t[0],t[1],t[2]),s&&6===s.length&&(e.faceVertexUvs.push(s[0],s[1]),e.faceVertexUvs.push(s[2],s[3]),e.faceVertexUvs.push(s[4],s[5]))):4===t.length&&(e.indices.push(t[0],t[1],t[3]),e.indices.push(t[1],t[2],t[3]))}}function c(e,t,n,s){switch(n){case"int8":case"char":return[e.getInt8(t),1];case"uint8":case"uchar":return[e.getUint8(t),1];case"int16":case"short":return[e.getInt16(t,s),2];case"uint16":case"ushort":return[e.getUint16(t,s),2];case"int32":case"int":return[e.getInt32(t,s),4];case"uint32":case"uint":return[e.getUint32(t,s),4];case"float32":case"float":return[e.getFloat32(t,s),4];case"float64":case"double":return[e.getFloat64(t,s),8]}}function u(e,t,n,s){const r={};let i,o=0;for(let a=0;a<n.length;a++)if("list"===n[a].type){const u=[];i=c(e,t+o,n[a].countType,s);const l=i[0];o+=i[1];for(let r=0;r<l;r++)i=c(e,t+o,n[a].itemType,s),u.push(i[0]),o+=i[1];r[n[a].name]=u}else i=c(e,t+o,n[a].type,s),r[n[a].name]=i[0],o+=i[1];return[r,o]}let l;const p=this;if(t instanceof ArrayBuffer){const s=e.LoaderUtils.decodeText(new Uint8Array(t)),r=n(s);l="ascii"===r.format?i(s,r):function(e,t){const n={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]},s="binary_little_endian"===t.format,r=new DataView(e,t.headerLength);let i,c=0;for(let e=0;e<t.elements.length;e++)for(let o=0;o<t.elements[e].count;o++){i=u(r,c,t.elements[e].properties,s),c+=i[1];const o=i[0];a(n,t.elements[e].name,o)}return o(n)}(t,r)}else l=i(t,n(t));return l}}exports.PLYLoader=t;
