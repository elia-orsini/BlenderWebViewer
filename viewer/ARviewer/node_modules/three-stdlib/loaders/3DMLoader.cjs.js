"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");const t=new WeakMap;class r extends e.Loader{constructor(e){super(e),this.libraryPath="",this.libraryPending=null,this.libraryBinary=null,this.libraryConfig={},this.url="",this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.workerConfig={},this.materials=[]}setLibraryPath(e){return this.libraryPath=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(r,s,o,a){const n=new e.FileLoader(this.manager);n.setPath(this.path),n.setResponseType("arraybuffer"),n.setRequestHeader(this.requestHeader),this.url=r,n.load(r,(e=>{if(t.has(e)){return t.get(e).promise.then(s).catch(a)}this.decodeObjects(e,r).then(s).catch(a)}),o,a)}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}decodeObjects(e,r){let s,o;const a=e.byteLength,n=this._getWorker(a).then((t=>(s=t,o=this.workerNextTaskID++,new Promise(((t,r)=>{s._callbacks[o]={resolve:t,reject:r},s.postMessage({type:"decode",id:o,buffer:e},[e])}))))).then((e=>this._createGeometry(e.data)));return n.catch((()=>!0)).then((()=>{s&&o&&this._releaseTask(s,o)})),t.set(e,{url:r,promise:n}),n}parse(e,t,r){this.decodeObjects(e,"").then(t).catch(r)}_compareMaterials(e){const t={};t.name=e.name,t.color={},t.color.r=e.color.r,t.color.g=e.color.g,t.color.b=e.color.b,t.type=e.type;for(let e=0;e<this.materials.length;e++){const r=this.materials[e],s={};if(s.name=r.name,s.color={},s.color.r=r.color.r,s.color.g=r.color.g,s.color.b=r.color.b,s.type=r.type,JSON.stringify(t)===JSON.stringify(s))return r}return this.materials.push(e),e}_createMaterial(t){if(void 0===t)return new e.MeshStandardMaterial({color:new e.Color(1,1,1),metalness:.8,name:"default",side:2});const r=t.diffuseColor,s=new e.Color(r.r/255,r.g/255,r.b/255);0===r.r&&0===r.g&&0===r.b&&(s.r=1,s.g=1,s.b=1);const o=new e.MeshStandardMaterial({color:s,name:t.name,side:2,transparent:t.transparency>0,opacity:1-t.transparency}),a=new e.TextureLoader;for(let e=0;e<t.textures.length;e++){const r=t.textures[e];if(null!==r.image){const e=a.load(r.image);switch(r.type){case"Diffuse":o.map=e;break;case"Bump":o.bumpMap=e;break;case"Transparency":o.alphaMap=e,o.transparent=!0;break;case"Emap":o.envMap=e}}}return o}_createGeometry(t){const r=new e.Object3D,s=[],o=[],a=[];r.userData.layers=t.layers,r.userData.groups=t.groups,r.userData.settings=t.settings,r.userData.objectType="File3dm",r.userData.materials=null,r.name=this.url;let n=t.objects;const i=t.materials;for(let e=0;e<n.length;e++){const c=n[e],l=c.attributes;switch(c.objectType){case"InstanceDefinition":o.push(c);break;case"InstanceReference":a.push(c);break;default:let e;if(l.materialIndex>=0){const t=i[l.materialIndex];let r=this._createMaterial(t);r=this._compareMaterials(r),e=this._createObject(c,r)}else{const t=this._createMaterial();e=this._createObject(c,t)}if(void 0===e)continue;const n=t.layers[l.layerIndex];e.visible=!n||t.layers[l.layerIndex].visible,l.isInstanceDefinitionObject?s.push(e):r.add(e)}}for(let t=0;t<o.length;t++){const i=o[t];n=[];for(let e=0;e<i.attributes.objectIds.length;e++){const t=i.attributes.objectIds[e];for(let e=0;e<s.length;e++){t===s[e].userData.attributes.id&&n.push(s[e])}}for(let t=0;t<a.length;t++){const s=a[t];if(s.geometry.parentIdefId===i.attributes.id){const t=new e.Object3D,o=s.geometry.xform.array,a=new e.Matrix4;a.set(o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],o[8],o[9],o[10],o[11],o[12],o[13],o[14],o[15]),t.applyMatrix4(a);for(let e=0;e<n.length;e++)t.add(n[e].clone(!0));r.add(t)}}}return r.userData.materials=this.materials,r}_createObject(t,r){const s=new e.BufferGeometryLoader,o=t.attributes;let a,n,i,c;switch(t.objectType){case"Point":case"PointSet":a=s.parse(t.geometry),a.attributes.hasOwnProperty("color")?n=new e.PointsMaterial({vertexColors:!0,sizeAttenuation:!1,size:2}):(i=o.drawColor,c=new e.Color(i.r/255,i.g/255,i.b/255),n=new e.PointsMaterial({color:c,sizeAttenuation:!1,size:2})),n=this._compareMaterials(n);const l=new e.Points(a,n);return l.userData.attributes=o,l.userData.objectType=t.objectType,o.name&&(l.name=o.name),l;case"Mesh":case"Extrusion":case"SubD":case"Brep":if(null===t.geometry)return;a=s.parse(t.geometry),a.attributes.hasOwnProperty("color")&&(r.vertexColors=!0),null===r&&(r=this._createMaterial(),r=this._compareMaterials(r));const u=new e.Mesh(a,r);return u.castShadow=o.castsShadows,u.receiveShadow=o.receivesShadows,u.userData.attributes=o,u.userData.objectType=t.objectType,o.name&&(u.name=o.name),u;case"Curve":a=s.parse(t.geometry),i=o.drawColor,c=new e.Color(i.r/255,i.g/255,i.b/255),n=new e.LineBasicMaterial({color:c}),n=this._compareMaterials(n);const h=new e.Line(a,n);return h.userData.attributes=o,h.userData.objectType=t.objectType,o.name&&(h.name=o.name),h;case"TextDot":a=t.geometry;const p=document.createElement("canvas").getContext("2d"),d=`${a.fontHeight}px ${a.fontFace}`;p.font=d;const y=p.measureText(a.text).width+10,g=a.fontHeight+10,m=window.devicePixelRatio;p.canvas.width=y*m,p.canvas.height=g*m,p.canvas.style.width=y+"px",p.canvas.style.height=g+"px",p.setTransform(m,0,0,m,0,0),p.font=d,p.textBaseline="middle",p.textAlign="center",c=o.drawColor,p.fillStyle=`rgba(${c.r},${c.g},${c.b},${c.a})`,p.fillRect(0,0,y,g),p.fillStyle="white",p.fillText(a.text,y/2,g/2);const b=new e.CanvasTexture(p.canvas);b.minFilter=e.LinearFilter,b.wrapS=e.ClampToEdgeWrapping,b.wrapT=e.ClampToEdgeWrapping,n=new e.SpriteMaterial({map:b,depthTest:!1});const f=new e.Sprite(n);return f.position.set(a.point[0],a.point[1],a.point[2]),f.scale.set(y/10,g/10,1),f.userData.attributes=o,f.userData.objectType=t.objectType,o.name&&(f.name=o.name),f;case"Light":let T;if(a=t.geometry,a.isDirectionalLight)T=new e.DirectionalLight,T.castShadow=o.castsShadows,T.position.set(a.location[0],a.location[1],a.location[2]),T.target.position.set(a.direction[0],a.direction[1],a.direction[2]),T.shadow.normalBias=.1;else if(a.isPointLight)T=new e.PointLight,T.castShadow=o.castsShadows,T.position.set(a.location[0],a.location[1],a.location[2]),T.shadow.normalBias=.1;else if(a.isRectangularLight){T=new e.RectAreaLight;const t=Math.abs(a.width[2]),r=Math.abs(a.length[0]);T.position.set(a.location[0]-r/2,a.location[1],a.location[2]-t/2),T.height=r,T.width=t,T.lookAt(new e.Vector3(a.direction[0],a.direction[1],a.direction[2]))}else if(a.isSpotLight)T=new e.SpotLight,T.castShadow=o.castsShadows,T.position.set(a.location[0],a.location[1],a.location[2]),T.target.position.set(a.direction[0],a.direction[1],a.direction[2]),T.angle=a.spotAngleRadians,T.shadow.normalBias=.1;else if(a.isLinearLight)return void console.warn("THREE.3DMLoader:  No conversion exists for linear lights.");return T&&(T.intensity=a.intensity,i=a.diffuse,c=new e.Color(i.r/255,i.g/255,i.b/255),T.color=c,T.userData.attributes=o,T.userData.objectType=t.objectType),T}}_initLibrary(){if(!this.libraryPending){const t=new e.FileLoader(this.manager);t.setPath(this.libraryPath);const r=new Promise(((e,r)=>{t.load("rhino3dm.js",e,void 0,r)})),o=new e.FileLoader(this.manager);o.setPath(this.libraryPath),o.setResponseType("arraybuffer");const a=new Promise(((e,t)=>{o.load("rhino3dm.wasm",e,void 0,t)}));this.libraryPending=Promise.all([r,a]).then((([e,t])=>{this.libraryConfig.wasmBinary=t;const r=s.toString(),o=["/* rhino3dm.js */",e,"/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([o]))}))}return this.libraryPending}_getWorker(e){return this._initLibrary().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",libraryConfig:this.libraryConfig}),e.onmessage=function(t){const r=t.data;switch(r.type){case"decode":e._callbacks[r.id].resolve(r);break;case"error":e._callbacks[r.id].reject(r);break;default:console.error('THREE.Rhino3dmLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const t=this.workerPool[this.workerPool.length-1];return t._taskLoad+=e,t}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function s(){let e,t,r;function s(e,t){const s=e.geometry(),n=e.attributes();let i,c,l,u,h,p=s.objectType;switch(p){case r.ObjectType.Curve:const e=a(s,100);l={},c={},u={},l.itemSize=3,l.type="Float32Array",l.array=[];for(let t=0;t<e.length;t++)l.array.push(e[t][0]),l.array.push(e[t][1]),l.array.push(e[t][2]);c.position=l,u.attributes=c,i={data:u};break;case r.ObjectType.Point:const d=s.location;l={};const y={};c={},u={},l.itemSize=3,l.type="Float32Array",l.array=[d[0],d[1],d[2]];const g=n.drawColor(t);y.itemSize=3,y.type="Float32Array",y.array=[g.r/255,g.g/255,g.b/255],c.position=l,c.color=y,u.attributes=c,i={data:u};break;case r.ObjectType.PointSet:case r.ObjectType.Mesh:i=s.toThreejsJSON();break;case r.ObjectType.Brep:const m=s.faces();h=new r.Mesh;for(let e=0;e<m.count;e++){const t=m.get(e),s=t.getMesh(r.MeshType.Any);s&&(h.append(s),s.delete()),t.delete()}h.faces().count>0&&(h.compact(),i=h.toThreejsJSON(),m.delete()),h.delete();break;case r.ObjectType.Extrusion:h=s.getMesh(r.MeshType.Any),h&&(i=h.toThreejsJSON(),h.delete());break;case r.ObjectType.TextDot:case r.ObjectType.Light:i=o(s);break;case r.ObjectType.InstanceReference:i=o(s),i.xform=o(s.xform),i.xform.array=s.xform.toFloatArray(!0);break;case r.ObjectType.SubD:s.subdivide(3),h=r.Mesh.createFromSubDControlNet(s),h&&(i=h.toThreejsJSON(),h.delete());break;default:console.warn(`THREE.3DMLoader: TODO: Implement ${p.constructor.name}`)}if(i)return c=o(n),c.geometry=o(s),n.groupCount>0&&(c.groupIds=n.getGroupList()),n.userStringCount>0&&(c.userStrings=n.getUserStrings()),s.userStringCount>0&&(c.geometry.userStrings=s.getUserStrings()),c.drawColor=n.drawColor(t),p=p.constructor.name,p=p.substring(11,p.length),{geometry:i,attributes:c,objectType:p};console.warn(`THREE.3DMLoader: ${p.constructor.name} has no associated mesh geometry.`)}function o(e){const t={};for(const r in e){const s=e[r];"function"!=typeof s&&("object"==typeof s&&null!==s&&s.hasOwnProperty("constructor")?t[r]={name:s.constructor.name,value:s.value}:t[r]=s)}return t}function a(e,t){let s=t,o=[];const n=[];if(e instanceof r.LineCurve)return[e.pointAtStart,e.pointAtEnd];if(e instanceof r.PolylineCurve){s=e.pointCount;for(let t=0;t<s;t++)o.push(e.point(t));return o}if(e instanceof r.PolyCurve){const t=e.segmentCount;for(let r=0;r<t;r++){const t=e.segmentCurve(r),n=a(t,s);o=o.concat(n),t.delete()}return o}if(e instanceof r.ArcCurve&&(s=Math.floor(e.angleDegrees/5),s=s<2?2:s),e instanceof r.NurbsCurve&&1===e.degree){const t=e.tryGetPolyline();for(let e=0;e<t.count;e++)o.push(t.get(e));return t.delete(),o}const i=e.domain,c=s-1;for(let t=0;t<s;t++){const r=i[0]+t/c*(i[1]-i[0]);if(r===i[0]||r===i[1]){n.push(r);continue}const s=e.tangentAt(r),o=e.tangentAt(n.slice(-1)[0]),a=s[0]*s[0]+s[1]*s[1]+s[2]*s[2],l=o[0]*o[0]+o[1]*o[1]+o[2]*o[2],u=Math.sqrt(a*l);let h;if(0===u)h=Math.PI/2;else{const e=(s.x*o.x+s.y*o.y+s.z*o.z)/u;h=Math.acos(Math.max(-1,Math.min(1,e)))}h<.1||n.push(r)}return o=n.map((t=>e.pointAt(t))),o}onmessage=function(a){const n=a.data;switch(n.type){case"init":t=n.libraryConfig;const a=t.wasmBinary;let i;e=new Promise((function(e){i={wasmBinary:a,onRuntimeInitialized:e},rhino3dm(i)})).then((()=>{r=i}));break;case"decode":const c=n.buffer;e.then((()=>{const e=function(e,t){const r=new Uint8Array(t),a=e.File3dm.fromByteArray(r),n=[],i=[],c=[],l=[],u=[],h=[],p=a.objects(),d=p.count;for(let e=0;e<d;e++){const t=p.get(e),r=s(t,a);t.delete(),r&&n.push(r)}for(let e=0;e<a.instanceDefinitions().count();e++){const t=a.instanceDefinitions().get(e),r=o(t);r.objectIds=t.getObjectIds(),n.push({geometry:null,attributes:r,objectType:"InstanceDefinition"})}const y=[e.TextureType.Diffuse,e.TextureType.Bump,e.TextureType.Transparency,e.TextureType.Opacity,e.TextureType.Emap],g=[e.TextureType.PBR_BaseColor,e.TextureType.PBR_Subsurface,e.TextureType.PBR_SubsurfaceScattering,e.TextureType.PBR_SubsurfaceScatteringRadius,e.TextureType.PBR_Metallic,e.TextureType.PBR_Specular,e.TextureType.PBR_SpecularTint,e.TextureType.PBR_Roughness,e.TextureType.PBR_Anisotropic,e.TextureType.PBR_Anisotropic_Rotation,e.TextureType.PBR_Sheen,e.TextureType.PBR_SheenTint,e.TextureType.PBR_Clearcoat,e.TextureType.PBR_ClearcoatBump,e.TextureType.PBR_ClearcoatRoughness,e.TextureType.PBR_OpacityIor,e.TextureType.PBR_OpacityRoughness,e.TextureType.PBR_Emission,e.TextureType.PBR_AmbientOcclusion,e.TextureType.PBR_Displacement];for(let e=0;e<a.materials().count();e++){const t=a.materials().get(e),r=t.physicallyBased();let s=o(t);const n=[];for(let e=0;e<y.length;e++){const r=t.getTexture(y[e]);if(r){let t=y[e].constructor.name;t=t.substring(12,t.length);const s={type:t},o=a.getEmbeddedFileAsBase64(r.fileName);o?s.image="data:image/png;base64,"+o:(console.warn(`THREE.3DMLoader: Image for ${t} texture not embedded in file.`),s.image=null),n.push(s),r.delete()}}if(s.textures=n,r.supported){console.log("pbr true");for(let e=0;e<g.length;e++){const r=t.getTexture(y[e]);if(r){const t=a.getEmbeddedFileAsBase64(r.fileName);let s=y[e].constructor.name;s=s.substring(12,s.length);const o={type:s,image:"data:image/png;base64,"+t};n.push(o),r.delete()}}const e=o(t.physicallyBased());s=Object.assign(e,s)}i.push(s),t.delete(),r.delete()}for(let e=0;e<a.layers().count();e++){const t=a.layers().get(e),r=o(t);c.push(r),t.delete()}for(let e=0;e<a.views().count();e++){const t=a.views().get(e),r=o(t);l.push(r),t.delete()}for(let e=0;e<a.namedViews().count();e++){const t=a.namedViews().get(e),r=o(t);u.push(r),t.delete()}for(let e=0;e<a.groups().count();e++){const t=a.groups().get(e),r=o(t);h.push(r),t.delete()}const m=o(a.settings());return a.delete(),{objects:n,materials:i,layers:c,views:l,namedViews:u,groups:h,settings:m}}(r,c);self.postMessage({type:"decode",id:n.id,data:e})}))}}}exports.Rhino3dmLoader=r;
