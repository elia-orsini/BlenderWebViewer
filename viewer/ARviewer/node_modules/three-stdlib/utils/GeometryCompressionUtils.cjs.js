"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three"),e={compressNormals:function(e,r){e.geometry||console.error("Mesh must contain geometry. ");const a=e.geometry.attributes.normal;if(a||console.error("Geometry must contain normal attribute. "),a.isPacked)return;3!=a.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");const o=a.array,i=a.count;let s;if("DEFAULT"==r){s=new Uint8Array(3*i);for(let t=0;t<o.length;t+=3){const e=this.EncodingFuncs.defaultEncode(o[t],o[t+1],o[t+2],1);s[t+0]=e[0],s[t+1]=e[1],s[t+2]=e[2]}e.geometry.setAttribute("normal",new t.BufferAttribute(s,3,!0)),e.geometry.attributes.normal.bytes=1*s.length}else if("OCT1Byte"==r){s=new Int8Array(2*i);for(let t=0;t<o.length;t+=3){const e=this.EncodingFuncs.octEncodeBest(o[t],o[t+1],o[t+2],1);s[t/3*2+0]=e[0],s[t/3*2+1]=e[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(s,2,!0)),e.geometry.attributes.normal.bytes=1*s.length}else if("OCT2Byte"==r){s=new Int16Array(2*i);for(let t=0;t<o.length;t+=3){const e=this.EncodingFuncs.octEncodeBest(o[t],o[t+1],o[t+2],2);s[t/3*2+0]=e[0],s[t/3*2+1]=e[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(s,2,!0)),e.geometry.attributes.normal.bytes=2*s.length}else if("ANGLES"==r){s=new Uint16Array(2*i);for(let t=0;t<o.length;t+=3){const e=this.EncodingFuncs.anglesEncode(o[t],o[t+1],o[t+2]);s[t/3*2+0]=e[0],s[t/3*2+1]=e[1]}e.geometry.setAttribute("normal",new t.BufferAttribute(s,2,!0)),e.geometry.attributes.normal.bytes=2*s.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");e.geometry.attributes.normal.needsUpdate=!0,e.geometry.attributes.normal.isPacked=!0,e.geometry.attributes.normal.packingMethod=r,e.material instanceof n||(e.material=(new n).copy(e.material)),"ANGLES"==r&&(e.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==r&&(e.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==r&&(e.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==r&&(e.material.defines.USE_PACKED_NORMAL=2)},compressPositions:function(e){e.geometry||console.error("Mesh must contain geometry. ");const r=e.geometry.attributes.position;if(r||console.error("Geometry must contain position attribute. "),r.isPacked)return;3!=r.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");const a=r.array,o=this.EncodingFuncs.quantizedEncode(a,2),i=o.quantized,s=o.decodeMat;null==e.geometry.boundingBox&&e.geometry.computeBoundingBox(),null==e.geometry.boundingSphere&&e.geometry.computeBoundingSphere(),e.geometry.setAttribute("position",new t.BufferAttribute(i,3)),e.geometry.attributes.position.isPacked=!0,e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.position.bytes=2*i.length,e.material instanceof n||(e.material=(new n).copy(e.material)),e.material.defines.USE_PACKED_POSITION=0,e.material.uniforms.quantizeMatPos.value=s,e.material.uniforms.quantizeMatPos.needsUpdate=!0},compressUvs:function(e){e.geometry||console.error("Mesh must contain geometry property. ");const r=e.geometry.attributes.uv;if(r||console.error("Geometry must contain uv attribute. "),r.isPacked)return;const a={min:1/0,max:-1/0},o=r.array;for(let t=0;t<o.length;t++)a.min=Math.min(a.min,o[t]),a.max=Math.max(a.max,o[t]);let i;if(a.min>=-1&&a.max<=1){i=new Uint16Array(o.length);for(let t=0;t<o.length;t+=2){const e=this.EncodingFuncs.defaultEncode(o[t],o[t+1],0,2);i[t]=e[0],i[t+1]=e[1]}e.geometry.setAttribute("uv",new t.BufferAttribute(i,2,!0)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*i.length,e.material instanceof n||(e.material=(new n).copy(e.material)),e.material.defines.USE_PACKED_UV=0}else i=this.EncodingFuncs.quantizedEncodeUV(o,2),e.geometry.setAttribute("uv",new t.BufferAttribute(i.quantized,2)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*i.quantized.length,e.material instanceof n||(e.material=(new n).copy(e.material)),e.material.defines.USE_PACKED_UV=1,e.material.uniforms.quantizeMatUV.value=i.decodeMat,e.material.uniforms.quantizeMatUV.needsUpdate=!0},EncodingFuncs:{defaultEncode:function(t,e,n,r){if(1==r){const r=Math.round(.5*(t+1)*255),a=Math.round(.5*(e+1)*255),o=Math.round(.5*(n+1)*255);return new Uint8Array([r,a,o])}if(2==r){const r=Math.round(.5*(t+1)*65535),a=Math.round(.5*(e+1)*65535),o=Math.round(.5*(n+1)*65535);return new Uint16Array([r,a,o])}console.error("number of bytes must be 1 or 2")},defaultDecode:function(t,e){return 1==e?[t[0]/255*2-1,t[1]/255*2-1,t[2]/255*2-1]:2==e?[t[0]/65535*2-1,t[1]/65535*2-1,t[2]/65535*2-1]:void console.error("number of bytes must be 1 or 2")},anglesEncode:function(t,e,n){const r=parseInt(.5*(1+Math.atan2(e,t)/Math.PI)*65535),a=parseInt(.5*(1+n)*65535);return new Uint16Array([r,a])},octEncodeBest:function(t,e,n,r){var a,o,i,s,h;return i=a=u(t,e,n,"floor","floor"),o=d(a),h=m(t,e,n,o),o=d(a=u(t,e,n,"ceil","floor")),(s=m(t,e,n,o))>h&&(i=a,h=s),o=d(a=u(t,e,n,"floor","ceil")),(s=m(t,e,n,o))>h&&(i=a,h=s),o=d(a=u(t,e,n,"ceil","ceil")),(s=m(t,e,n,o))>h&&(i=a),i;function u(t,e,a,o,i){var s=t/(Math.abs(t)+Math.abs(e)+Math.abs(a)),h=e/(Math.abs(t)+Math.abs(e)+Math.abs(a));if(n<0){var u=(1-Math.abs(h))*(s>=0?1:-1),d=(1-Math.abs(s))*(h>=0?1:-1);s=u,h=d;var m=1-Math.abs(s)-Math.abs(h);m>0&&(m+=.001,s+=s>0?m/2:-m/2,h+=h>0?m/2:-m/2)}return 1==r?new Int8Array([Math[o](127.5*s+(s<0?1:0)),Math[i](127.5*h+(h<0?1:0))]):2==r?new Int16Array([Math[o](32767.5*s+(s<0?1:0)),Math[i](32767.5*h+(h<0?1:0))]):void 0}function d(t){var e=t[0],n=t[1];1==r?(e/=e<0?127:128,n/=n<0?127:128):2==r&&(e/=e<0?32767:32768,n/=n<0?32767:32768);var a=1-Math.abs(e)-Math.abs(n);if(a<0){var o=e;e=(1-Math.abs(n))*(e>=0?1:-1),n=(1-Math.abs(o))*(n>=0?1:-1)}var i=Math.sqrt(e*e+n*n+a*a);return[e/i,n/i,a/i]}function m(t,e,n,r){return t*r[0]+e*r[1]+n*r[2]}},quantizedEncode:function(e,n){let r,a;1==n?(r=new Uint8Array(e.length),a=255):2==n?(r=new Uint16Array(e.length),a=65535):console.error("number of bytes error! ");const o=new t.Matrix4,i=new Float32Array(3),s=new Float32Array(3);i[0]=i[1]=i[2]=Number.MAX_VALUE,s[0]=s[1]=s[2]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=3)i[0]=Math.min(i[0],e[t+0]),i[1]=Math.min(i[1],e[t+1]),i[2]=Math.min(i[2],e[t+2]),s[0]=Math.max(s[0],e[t+0]),s[1]=Math.max(s[1],e[t+1]),s[2]=Math.max(s[2],e[t+2]);o.scale(new t.Vector3((s[0]-i[0])/a,(s[1]-i[1])/a,(s[2]-i[2])/a)),o.elements[12]=i[0],o.elements[13]=i[1],o.elements[14]=i[2],o.transpose();const h=new Float32Array([s[0]!==i[0]?a/(s[0]-i[0]):0,s[1]!==i[1]?a/(s[1]-i[1]):0,s[2]!==i[2]?a/(s[2]-i[2]):0]);for(let t=0;t<e.length;t+=3)r[t+0]=Math.floor((e[t+0]-i[0])*h[0]),r[t+1]=Math.floor((e[t+1]-i[1])*h[1]),r[t+2]=Math.floor((e[t+2]-i[2])*h[2]);return{quantized:r,decodeMat:o}},quantizedEncodeUV:function(e,n){let r,a;1==n?(r=new Uint8Array(e.length),a=255):2==n?(r=new Uint16Array(e.length),a=65535):console.error("number of bytes error! ");const o=new t.Matrix3,i=new Float32Array(2),s=new Float32Array(2);i[0]=i[1]=Number.MAX_VALUE,s[0]=s[1]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=2)i[0]=Math.min(i[0],e[t+0]),i[1]=Math.min(i[1],e[t+1]),s[0]=Math.max(s[0],e[t+0]),s[1]=Math.max(s[1],e[t+1]);o.scale((s[0]-i[0])/a,(s[1]-i[1])/a),o.elements[6]=i[0],o.elements[7]=i[1],o.transpose();const h=new Float32Array([s[0]!==i[0]?a/(s[0]-i[0]):0,s[1]!==i[1]?a/(s[1]-i[1]):0]);for(let t=0;t<e.length;t+=2)r[t+0]=Math.floor((e[t+0]-i[0])*h[0]),r[t+1]=Math.floor((e[t+1]-i[1])*h[1]);return{quantized:r,decodeMat:o}}}};class n extends t.MeshPhongMaterial{constructor(e){super(),this.defines={},this.type="PackedPhongMaterial",this.uniforms=t.UniformsUtils.merge([t.ShaderLib.phong.uniforms,{quantizeMatPos:{value:null},quantizeMatUV:{value:null}}]),this.vertexShader=["#define PHONG","varying vec3 vViewPosition;","#ifndef FLAT_SHADED","varying vec3 vNormal;","#endif",t.ShaderChunk.common,t.ShaderChunk.uv_pars_vertex,t.ShaderChunk.uv2_pars_vertex,t.ShaderChunk.displacementmap_pars_vertex,t.ShaderChunk.envmap_pars_vertex,t.ShaderChunk.color_pars_vertex,t.ShaderChunk.fog_pars_vertex,t.ShaderChunk.morphtarget_pars_vertex,t.ShaderChunk.skinning_pars_vertex,t.ShaderChunk.shadowmap_pars_vertex,t.ShaderChunk.logdepthbuf_pars_vertex,t.ShaderChunk.clipping_planes_pars_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif","#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif","void main() {",t.ShaderChunk.uv_vertex,"#ifdef USE_UV\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif",t.ShaderChunk.uv2_vertex,t.ShaderChunk.color_vertex,t.ShaderChunk.beginnormal_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t",t.ShaderChunk.morphnormal_vertex,t.ShaderChunk.skinbase_vertex,t.ShaderChunk.skinnormal_vertex,t.ShaderChunk.defaultnormal_vertex,"#ifndef FLAT_SHADED","\tvNormal = normalize( transformedNormal );","#endif",t.ShaderChunk.begin_vertex,"#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif",t.ShaderChunk.morphtarget_vertex,t.ShaderChunk.skinning_vertex,t.ShaderChunk.displacementmap_vertex,t.ShaderChunk.project_vertex,t.ShaderChunk.logdepthbuf_vertex,t.ShaderChunk.clipping_planes_vertex,"vViewPosition = - mvPosition.xyz;",t.ShaderChunk.worldpos_vertex,t.ShaderChunk.envmap_vertex,t.ShaderChunk.shadowmap_vertex,t.ShaderChunk.fog_vertex,"}"].join("\n"),this.fragmentShader=["#define PHONG","uniform vec3 diffuse;","uniform vec3 emissive;","uniform vec3 specular;","uniform float shininess;","uniform float opacity;",t.ShaderChunk.common,t.ShaderChunk.packing,t.ShaderChunk.dithering_pars_fragment,t.ShaderChunk.color_pars_fragment,t.ShaderChunk.uv_pars_fragment,t.ShaderChunk.uv2_pars_fragment,t.ShaderChunk.map_pars_fragment,t.ShaderChunk.alphamap_pars_fragment,t.ShaderChunk.aomap_pars_fragment,t.ShaderChunk.lightmap_pars_fragment,t.ShaderChunk.emissivemap_pars_fragment,t.ShaderChunk.envmap_common_pars_fragment,t.ShaderChunk.envmap_pars_fragment,t.ShaderChunk.cube_uv_reflection_fragment,t.ShaderChunk.fog_pars_fragment,t.ShaderChunk.bsdfs,t.ShaderChunk.lights_pars_begin,t.ShaderChunk.lights_phong_pars_fragment,t.ShaderChunk.shadowmap_pars_fragment,t.ShaderChunk.bumpmap_pars_fragment,t.ShaderChunk.normalmap_pars_fragment,t.ShaderChunk.specularmap_pars_fragment,t.ShaderChunk.logdepthbuf_pars_fragment,t.ShaderChunk.clipping_planes_pars_fragment,"void main() {",t.ShaderChunk.clipping_planes_fragment,"vec4 diffuseColor = vec4( diffuse, opacity );","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","vec3 totalEmissiveRadiance = emissive;",t.ShaderChunk.logdepthbuf_fragment,t.ShaderChunk.map_fragment,t.ShaderChunk.color_fragment,t.ShaderChunk.alphamap_fragment,t.ShaderChunk.alphatest_fragment,t.ShaderChunk.specularmap_fragment,t.ShaderChunk.normal_fragment_begin,t.ShaderChunk.normal_fragment_maps,t.ShaderChunk.emissivemap_fragment,t.ShaderChunk.lights_phong_fragment,t.ShaderChunk.lights_fragment_begin,t.ShaderChunk.lights_fragment_maps,t.ShaderChunk.lights_fragment_end,t.ShaderChunk.aomap_fragment,"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",t.ShaderChunk.envmap_fragment,"gl_FragColor = vec4( outgoingLight, diffuseColor.a );",t.ShaderChunk.tonemapping_fragment,t.ShaderChunk.encodings_fragment,t.ShaderChunk.fog_fragment,t.ShaderChunk.premultiplied_alpha_fragment,t.ShaderChunk.dithering_fragment,"}"].join("\n"),this.setValues(e)}}exports.GeometryCompressionUtils=e,exports.PackedPhongMaterial=n;
