"use strict";var e=require("three"),t=require("./types/helpers.cjs.js");const r=(t,r)=>{const i=null!==t[0].index,s=new Set(Object.keys(t[0].attributes)),n=new Set(Object.keys(t[0].morphAttributes)),u={},a={},l=t[0].morphTargetsRelative,f=new e.BufferGeometry;let m=0;if(t.forEach(((e,t)=>{let o=0;if(i!==(null!==e.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let r in e.attributes){if(!s.has(r))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+r+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[r]&&(u[r]=[]),u[r].push(e.attributes[r]),o++}if(o!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(l!==e.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let r in e.morphAttributes){if(!n.has(r))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[r]&&(a[r]=[]),a[r].push(e.morphAttributes[r])}if(f.userData.mergedUserData=f.userData.mergedUserData||[],f.userData.mergedUserData.push(e.userData),r){let r;if(e.index)r=e.index.count;else{if(void 0===e.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;r=e.attributes.position.count}f.addGroup(m,r,t),m+=r}})),i){let e=0;const r=[];t.forEach((t=>{const o=t.index;for(let t=0;t<o.count;++t)r.push(o.getX(t)+e);e+=t.attributes.position.count})),f.setIndex(r)}for(let e in u){const t=o(u[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;f.setAttribute(e,t)}for(let e in a){const t=a[e][0].length;if(0===t)break;f.morphAttributes=f.morphAttributes||{},f.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<a[e].length;++o)t.push(a[e][o][r]);const i=o(t);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;f.morphAttributes[e].push(i)}}return f},o=t=>{let r,o,i,s=0;if(t.forEach((e=>(void 0===r&&(r=e.array.constructor),r!==e.array.constructor?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null):(void 0===o&&(o=e.itemSize),o!==e.itemSize?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null):(void 0===i&&(i=e.normalized),i!==e.normalized?(console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null):void(s+=e.array.length)))))),r&&o){const n=new r(s);let u=0;return t.forEach((e=>{n.set(e.array,u),u+=e.array.length})),new e.BufferAttribute(n,o,i)}},i=r=>{let o,i=0,s=0;for(let e=0,t=r.length;e<t;++e){const t=r[e];if(void 0===o&&(o=t.array.constructor),o!==t.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;i+=t.array.length,s+=t.itemSize}const n=new e.InterleavedBuffer(new o(i),s);let u=0;const a=[],l=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let o=0,i=r.length;o<i;o++){const i=r[o],s=i.itemSize,m=i.count,c=new e.InterleavedBufferAttribute(n,s,u,i.normalized);a.push(c),u+=s;for(let e=0;e<m;e++)for(let r=0;r<s;r++){t.getWithKey(c,f[r])(e,t.getWithKey(i,l[r])(e))}}return a};function s(e){let t=0;for(let r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}function n(t,r=1e-4){r=Math.max(r,Number.EPSILON);const o={},i=t.getIndex(),s=t.getAttribute("position"),n=i?i.count:s.count;let u=0;const a=Object.keys(t.attributes),l={},f={},m=[],c=["getX","getY","getZ","getW"];for(let e=0,r=a.length;e<r;e++){const r=a[e];l[r]=[];const o=t.morphAttributes[r];o&&(f[r]=new Array(o.length).fill(0).map((()=>[])))}const g=Math.log10(1/r),h=Math.pow(10,g);for(let e=0;e<n;e++){const r=i?i.getX(e):e;let s="";for(let e=0,o=a.length;e<o;e++){const o=a[e],i=t.getAttribute(o),n=i.itemSize;for(let e=0;e<n;e++)s+=~~(i[c[e]](r)*h)+","}if(s in o)m.push(o[s]);else{for(let e=0,o=a.length;e<o;e++){const o=a[e],i=t.getAttribute(o),s=t.morphAttributes[o],n=i.itemSize,u=l[o],m=f[o];for(let e=0;e<n;e++){const t=c[e];if(u.push(i[t](r)),s)for(let e=0,o=s.length;e<o;e++)m[e].push(s[e][t](r))}}o[s]=u,m.push(u),u++}}const d=t.clone();for(let r=0,o=a.length;r<o;r++){const o=a[r],i=t.getAttribute(o),s=new i.array.constructor(l[o]),n=new e.BufferAttribute(s,i.itemSize,i.normalized);if(d.setAttribute(o,n),o in f)for(let r=0;r<f[o].length;r++){const i=t.morphAttributes[o][r],s=new i.array.constructor(f[o][r]),n=new e.BufferAttribute(s,i.itemSize,i.normalized);d.morphAttributes[o][r]=n}}return d.setIndex(m),d}function u(t,r){if(r===e.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){let o=t.getIndex();if(null===o){const e=[],r=t.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<r.count;t++)e.push(t);t.setIndex(e),o=t.getIndex()}const i=o.count-2,s=[];if(o)if(r===e.TriangleFanDrawMode)for(let e=1;e<=i;e++)s.push(o.getX(0)),s.push(o.getX(e)),s.push(o.getX(e+1));else for(let e=0;e<i;e++)e%2==0?(s.push(o.getX(e)),s.push(o.getX(e+1)),s.push(o.getX(e+2))):(s.push(o.getX(e+2)),s.push(o.getX(e+1)),s.push(o.getX(e)));s.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const n=t.clone();return n.setIndex(s),n.clearGroups(),n}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),t}function a(t){if(!0!==t.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const r=new e.Vector3,o=new e.Vector3,i=new e.Vector3,s=new e.Vector3,n=new e.Vector3,u=new e.Vector3,a=new e.Vector3,l=new e.Vector3,f=new e.Vector3;function m(e,t,m,c,g,h,d,b,p){r.fromBufferAttribute(m,h),o.fromBufferAttribute(m,d),i.fromBufferAttribute(m,b);const y=e.morphTargetInfluences;if(t.morphTargets&&c&&y){a.set(0,0,0),l.set(0,0,0),f.set(0,0,0);for(let e=0,t=c.length;e<t;e++){const t=y[e],m=c[e];0!==t&&(s.fromBufferAttribute(m,h),n.fromBufferAttribute(m,d),u.fromBufferAttribute(m,b),g?(a.addScaledVector(s,t),l.addScaledVector(n,t),f.addScaledVector(u,t)):(a.addScaledVector(s.sub(r),t),l.addScaledVector(n.sub(o),t),f.addScaledVector(u.sub(i),t)))}r.add(a),o.add(l),i.add(f)}e.isSkinnedMesh&&(e.boneTransform(h,r),e.boneTransform(d,o),e.boneTransform(b,i)),p[3*h+0]=r.x,p[3*h+1]=r.y,p[3*h+2]=r.z,p[3*d+0]=o.x,p[3*d+1]=o.y,p[3*d+2]=o.z,p[3*b+0]=i.x,p[3*b+1]=i.y,p[3*b+2]=i.z}const c=t.geometry,g=t.material;let h,d,b;const p=c.index,y=c.attributes.position,A=c.morphAttributes.position,B=c.morphTargetsRelative,w=c.attributes.normal,E=c.morphAttributes.position,x=c.groups,T=c.drawRange;let G,M,S,v,U,z,R,X;const D=new Float32Array(y.count*y.itemSize),V=new Float32Array(w.count*w.itemSize);if(null!==p)if(Array.isArray(g))for(G=0,S=x.length;G<S;G++)for(U=x[G],z=g[U.materialIndex],R=Math.max(U.start,T.start),X=Math.min(U.start+U.count,T.start+T.count),M=R,v=X;M<v;M+=3)h=p.getX(M),d=p.getX(M+1),b=p.getX(M+2),m(t,z,y,A,B,h,d,b,D),m(t,z,w,E,B,h,d,b,V);else for(R=Math.max(0,T.start),X=Math.min(p.count,T.start+T.count),G=R,S=X;G<S;G+=3)h=p.getX(G),d=p.getX(G+1),b=p.getX(G+2),m(t,g,y,A,B,h,d,b,D),m(t,g,w,E,B,h,d,b,V);else if(void 0!==y)if(Array.isArray(g))for(G=0,S=x.length;G<S;G++)for(U=x[G],z=g[U.materialIndex],R=Math.max(U.start,T.start),X=Math.min(U.start+U.count,T.start+T.count),M=R,v=X;M<v;M+=3)h=M,d=M+1,b=M+2,m(t,z,y,A,B,h,d,b,D),m(t,z,w,E,B,h,d,b,V);else for(R=Math.max(0,T.start),X=Math.min(y.count,T.start+T.count),G=R,S=X;G<S;G+=3)h=G,d=G+1,b=G+2,m(t,g,y,A,B,h,d,b,D),m(t,g,w,E,B,h,d,b,V);return{positionAttribute:y,normalAttribute:w,morphedPositionAttribute:new e.Float32BufferAttribute(D,3),morphedNormalAttribute:new e.Float32BufferAttribute(V,3)}}var l=Object.freeze({__proto__:null,mergeBufferGeometries:r,mergeBufferAttributes:o,interleaveAttributes:i,estimateBytesUsed:s,mergeVertices:n,toTrianglesDrawMode:u,computeMorphedAttributes:a});exports.BufferGeometryUtils=l,exports.computeMorphedAttributes=a,exports.estimateBytesUsed=s,exports.interleaveAttributes=i,exports.mergeBufferAttributes=o,exports.mergeBufferGeometries=r,exports.mergeVertices=n,exports.toTrianglesDrawMode=u;
