"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new(require("three").Vector2)(.001953125,0)},cKernel:{value:[]}},vertexShader:["uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float cKernel[ KERNEL_SIZE_INT ];","uniform sampler2D tDiffuse;","uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","\tvec2 imageCoord = vUv;","\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );","\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {","\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];","\t\timageCoord += uImageIncrement;","\t}","\tgl_FragColor = sum;","}"].join("\n"),buildKernel:function(e){function t(e,t){return Math.exp(-e*e/(2*t*t))}const r=Math.min(2*Math.ceil(3*e)+1,25),n=.5*(r-1),i=new Array(r);let o=0;for(let u=0;u<r;++u)i[u]=t(u-n,e),o+=i[u];for(let e=0;e<r;++e)i[e]/=o;return i}};exports.ConvolutionShader=e;
