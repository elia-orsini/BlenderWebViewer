"use strict";var e=require("./constants.cjs.js"),t=require("three");function r(e){const t=this.properties,r=this.nodes,a=this.shaderModules,n=e.target,o=t.get(n),i=r.get(n);n.removeEventListener("dispose",o.disposeCallback),t.remove(n),r.remove(n),a.vertex.delete(i.vertexShader),a.fragment.delete(i.fragmentShader)}module.exports=class{constructor(e,t,r,a,n,o){this.renderer=e,this.properties=t,this.device=r,this.glslang=a,this.sampleCount=n,this.nodes=o,this.pipelines=new WeakMap,this.shaderAttributes=new WeakMap,this.shaderModules={vertex:new Map,fragment:new Map}}get(a){let n=this.pipelines.get(a);if(void 0===n){const o=this.device,i=this.properties,s=a.material,l=this.nodes.get(s),c=this.glslang;let d=this.shaderModules.vertex.get(l.vertexShader);if(void 0===d){const e=c.compileGLSL(l.vertexShader,"vertex");d={module:o.createShaderModule({code:e}),entryPoint:"main"},this.shaderModules.vertex.set(l.vertexShader,d)}let p=this.shaderModules.fragment.get(l.fragmentShader);if(void 0===p){const e=c.compileGLSL(l.fragmentShader,"fragment");p={module:o.createShaderModule({code:e}),entryPoint:"main"},this.shaderModules.fragment.set(l.fragmentShader,p)}const u=i.get(s);if(void 0===u.disposeCallback){const e=r.bind(this);u.disposeCallback=e,s.addEventListener("dispose",e)}const h=this._parseShaderAttributes(l.vertexShader),F=[],P=a.geometry;for(let t of h){const r=t.name,a=P.getAttribute(r),n=void 0!==a&&a.isInstancedBufferAttribute?e.GPUInputStepMode.Instance:e.GPUInputStepMode.Vertex;F.push({arrayStride:t.arrayStride,attributes:[{shaderLocation:t.slot,offset:0,format:t.format}],stepMode:n})}let G;if(a.isLine){G=(P.index?P.index.count:P.attributes.position.count)>65535?e.GPUIndexFormat.Uint32:e.GPUIndexFormat.Uint16}let U={},m={};!0===s.transparent&&s.blending!==t.NoBlending&&(U=this._getAlphaBlend(s),m=this._getColorBlend(s));let g={};!0===s.stencilWrite&&(g={compare:this._getStencilCompare(s),failOp:this._getStencilOperation(s.stencilFail),depthFailOp:this._getStencilOperation(s.stencilZFail),passOp:this._getStencilOperation(s.stencilZPass)});const S=this._getPrimitiveTopology(a),b=this._getRasterizationStateDescriptor(s),B=this._getColorWriteMask(s),k=this._getDepthCompare(s),v=this._getColorFormat(this.renderer),C=this._getDepthStencilFormat(this.renderer);n=o.createRenderPipeline({vertexStage:d,fragmentStage:p,primitiveTopology:S,rasterizationState:b,colorStates:[{format:v,alphaBlend:U,colorBlend:m,writeMask:B}],depthStencilState:{format:C,depthWriteEnabled:s.depthWrite,depthCompare:k,stencilFront:g,stencilBack:{},stencilReadMask:s.stencilFuncMask,stencilWriteMask:s.stencilWriteMask},vertexState:{indexFormat:G,vertexBuffers:F},sampleCount:this.sampleCount}),this.pipelines.set(a,n),this.shaderAttributes.set(n,h)}return n}getShaderAttributes(e){return this.shaderAttributes.get(e)}dispose(){this.pipelines=new WeakMap,this.shaderAttributes=new WeakMap,this.shaderModules={vertex:new Map,fragment:new Map}}_getArrayStride(e){return"float"===e?4:"vec2"===e?8:"vec3"===e?12:"vec4"===e?16:"int"===e?4:"ivec2"===e?8:"ivec3"===e?12:"ivec4"===e?16:"uint"===e?4:"uvec2"===e?8:"uvec3"===e?12:"uvec4"===e?16:void console.error("THREE.WebGPURenderer: Shader variable type not supported yet.",e)}_getAlphaBlend(r){const a=r.blending,n=r.premultipliedAlpha;let o;switch(a){case t.NormalBlending:!1===n&&(o={srcFactor:e.GPUBlendFactor.One,dstFactor:e.GPUBlendFactor.OneMinusSrcAlpha,operation:e.GPUBlendOperation.Add});break;case t.AdditiveBlending:break;case t.SubtractiveBlending:!0===n&&(o={srcFactor:e.GPUBlendFactor.OneMinusSrcColor,dstFactor:e.GPUBlendFactor.OneMinusSrcAlpha,operation:e.GPUBlendOperation.Add});break;case t.MultiplyBlending:!0===n&&(o={srcFactor:e.GPUBlendFactor.Zero,dstFactor:e.GPUBlendFactor.SrcAlpha,operation:e.GPUBlendOperation.Add});break;case t.CustomBlending:const i=r.blendSrcAlpha,s=r.blendDstAlpha,l=r.blendEquationAlpha;null!==i&&null!==s&&null!==l&&(o={srcFactor:this._getBlendFactor(i),dstFactor:this._getBlendFactor(s),operation:this._getBlendOperation(l)});break;default:console.error("THREE.WebGPURenderer: Blending not supported.",a)}return o}_getBlendFactor(r){let a;switch(r){case t.ZeroFactor:a=e.GPUBlendFactor.Zero;break;case t.OneFactor:a=e.GPUBlendFactor.One;break;case t.SrcColorFactor:a=e.GPUBlendFactor.SrcColor;break;case t.OneMinusSrcColorFactor:a=e.GPUBlendFactor.OneMinusSrcColor;break;case t.SrcAlphaFactor:a=e.GPUBlendFactor.SrcAlpha;break;case t.OneMinusSrcAlphaFactor:a=e.GPUBlendFactor.OneMinusSrcAlpha;break;case t.DstColorFactor:a=e.GPUBlendFactor.DstColor;break;case t.OneMinusDstColorFactor:a=e.GPUBlendFactor.OneMinusDstColor;break;case t.DstAlphaFactor:a=e.GPUBlendFactor.DstAlpha;break;case t.OneMinusDstAlphaFactor:a=e.GPUBlendFactor.OneMinusDstAlpha;break;case t.SrcAlphaSaturateFactor:a=e.GPUBlendFactor.SrcAlphaSaturated;break;case e.BlendColorFactor:a=e.GPUBlendFactor.BlendColor;break;case e.OneMinusBlendColorFactor:a=e.GPUBlendFactor.OneMinusBlendColor;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",r)}return a}_getBlendOperation(r){let a;switch(r){case t.AddEquation:a=e.GPUBlendOperation.Add;break;case t.SubtractEquation:a=e.GPUBlendOperation.Subtract;break;case t.ReverseSubtractEquation:a=e.GPUBlendOperation.ReverseSubtract;break;case t.MinEquation:a=e.GPUBlendOperation.Min;break;case t.MaxEquation:a=e.GPUBlendOperation.Max;break;default:console.error("THREE.WebGPURenderer: Blend equation not supported.",r)}return a}_getColorBlend(r){const a=r.blending,n=r.premultipliedAlpha,o={srcFactor:null,dstFactor:null,operation:null};switch(a){case t.NormalBlending:o.srcFactor=!0===n?e.GPUBlendFactor.One:e.GPUBlendFactor.SrcAlpha,o.dstFactor=e.GPUBlendFactor.OneMinusSrcAlpha,o.operation=e.GPUBlendOperation.Add;break;case t.AdditiveBlending:o.srcFactor=!0===n?e.GPUBlendFactor.One:e.GPUBlendFactor.SrcAlpha,o.operation=e.GPUBlendOperation.Add;break;case t.SubtractiveBlending:o.srcFactor=e.GPUBlendFactor.Zero,o.dstFactor=!0===n?e.GPUBlendFactor.Zero:e.GPUBlendFactor.OneMinusSrcColor,o.operation=e.GPUBlendOperation.Add;break;case t.MultiplyBlending:o.srcFactor=e.GPUBlendFactor.Zero,o.dstFactor=e.GPUBlendFactor.SrcColor,o.operation=e.GPUBlendOperation.Add;break;case t.CustomBlending:o.srcFactor=this._getBlendFactor(r.blendSrc),o.dstFactor=this._getBlendFactor(r.blendDst),o.operation=this._getBlendOperation(r.blendEquation);break;default:console.error("THREE.WebGPURenderer: Blending not supported.",a)}return o}_getColorFormat(t){let r;const a=t.getRenderTarget();if(null!==a){r=this.properties.get(a).colorTextureFormat}else r=e.GPUTextureFormat.BRGA8Unorm;return r}_getColorWriteMask(t){return!0===t.colorWrite?e.GPUColorWriteFlags.All:e.GPUColorWriteFlags.None}_getDepthCompare(r){let a;if(!1===r.depthTest)a=e.GPUCompareFunction.Always;else{const n=r.depthFunc;switch(n){case t.NeverDepth:a=e.GPUCompareFunction.Never;break;case t.AlwaysDepth:a=e.GPUCompareFunction.Always;break;case t.LessDepth:a=e.GPUCompareFunction.Less;break;case t.LessEqualDepth:a=e.GPUCompareFunction.LessEqual;break;case t.EqualDepth:a=e.GPUCompareFunction.Equal;break;case t.GreaterEqualDepth:a=e.GPUCompareFunction.GreaterEqual;break;case t.GreaterDepth:a=e.GPUCompareFunction.Greater;break;case t.NotEqualDepth:a=e.GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid depth function.",n)}}return a}_getDepthStencilFormat(t){let r;const a=t.getRenderTarget();if(null!==a){r=this.properties.get(a).depthTextureFormat}else r=e.GPUTextureFormat.Depth24PlusStencil8;return r}_getPrimitiveTopology(t){return t.isMesh?e.GPUPrimitiveTopology.TriangleList:t.isPoints?e.GPUPrimitiveTopology.PointList:t.isLine?e.GPUPrimitiveTopology.LineStrip:t.isLineSegments?e.GPUPrimitiveTopology.LineList:void 0}_getRasterizationStateDescriptor(r){const a={};switch(r.side){case t.FrontSide:a.frontFace=e.GPUFrontFace.CCW,a.cullMode=e.GPUCullMode.Back;break;case t.BackSide:a.frontFace=e.GPUFrontFace.CW,a.cullMode=e.GPUCullMode.Back;break;case t.DoubleSide:a.frontFace=e.GPUFrontFace.CCW,a.cullMode=e.GPUCullMode.None;break;default:console.error("THREE.WebGPURenderer: Unknown Material.side value.",r.side)}return a}_getStencilCompare(r){let a;const n=r.stencilFunc;switch(n){case t.NeverStencilFunc:a=e.GPUCompareFunction.Never;break;case t.AlwaysStencilFunc:a=e.GPUCompareFunction.Always;break;case t.LessStencilFunc:a=e.GPUCompareFunction.Less;break;case t.LessEqualStencilFunc:a=e.GPUCompareFunction.LessEqual;break;case t.EqualStencilFunc:a=e.GPUCompareFunction.Equal;break;case t.GreaterEqualStencilFunc:a=e.GPUCompareFunction.GreaterEqual;break;case t.GreaterStencilFunc:a=e.GPUCompareFunction.Greater;break;case t.NotEqualStencilFunc:a=e.GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",n)}return a}_getStencilOperation(r){let a;switch(r){case t.KeepStencilOp:a=e.GPUStencilOperation.Keep;break;case t.ZeroStencilOp:a=e.GPUStencilOperation.Zero;break;case t.ReplaceStencilOp:a=e.GPUStencilOperation.Replace;break;case t.InvertStencilOp:a=e.GPUStencilOperation.Invert;break;case t.IncrementStencilOp:a=e.GPUStencilOperation.IncrementClamp;break;case t.DecrementStencilOp:a=e.GPUStencilOperation.DecrementClamp;break;case t.IncrementWrapStencilOp:a=e.GPUStencilOperation.IncrementWrap;break;case t.DecrementWrapStencilOp:a=e.GPUStencilOperation.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",a)}return a}_getVertexFormat(t){return"float"===t?e.GPUVertexFormat.Float:"vec2"===t?e.GPUVertexFormat.Float2:"vec3"===t?e.GPUVertexFormat.Float3:"vec4"===t?e.GPUVertexFormat.Float4:"int"===t?e.GPUVertexFormat.Int:"ivec2"===t?e.GPUVertexFormat.Int2:"ivec3"===t?e.GPUVertexFormat.Int3:"ivec4"===t?e.GPUVertexFormat.Int4:"uint"===t?e.GPUVertexFormat.UInt:"uvec2"===t?e.GPUVertexFormat.UInt2:"uvec3"===t?e.GPUVertexFormat.UInt3:"uvec4"===t?e.GPUVertexFormat.UInt4:void console.error("THREE.WebGPURenderer: Shader variable type not supported yet.",t)}_parseShaderAttributes(e){const t=/\s*layout\s*\(\s*location\s*=\s*(?<location>[0-9]+)\s*\)\s*in\s+(?<type>\w+)\s+(?<name>\w+)\s*;/gim;let r=null;const a=[];for(;r=t.exec(e);){const e=parseInt(r.groups.location),t=this._getArrayStride(r.groups.type),n=this._getVertexFormat(r.groups.type);a.push({name:r.groups.name,arrayStride:t,slot:e,format:n})}return a.sort((function(e,t){return e.slot-t.slot}))}};
