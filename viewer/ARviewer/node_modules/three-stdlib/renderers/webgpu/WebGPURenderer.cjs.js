"use strict";var e=require("./constants.cjs.js"),t=require("./WebGPUObjects.cjs.js"),s=require("./WebGPUAttributes.cjs.js"),i=require("./WebGPUGeometries.cjs.js"),r=require("./WebGPUInfo.cjs.js"),o=require("./WebGPUProperties.cjs.js"),n=require("./WebGPURenderPipelines.cjs.js"),h=require("./WebGPUComputePipelines.cjs.js"),a=require("./WebGPUBindings.cjs.js"),l=require("./WebGPURenderLists.cjs.js"),u=require("./WebGPUTextures.cjs.js"),c=require("./WebGPUBackground.cjs.js"),d=require("./nodes/WebGPUNodes.cjs.js"),p=require("@webgpu/glslang/dist/web-devel/glslang"),_=require("three");function m(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}require("./WebGPUTextureUtils.cjs.js"),require("./nodes/WebGPUNodeBuilder.cjs.js"),require("./nodes/WebGPUNodeUniformsGroup.cjs.js"),require("./WebGPUUniformsGroup.cjs.js"),require("./WebGPUBinding.cjs.js"),require("./nodes/WebGPUNodeUniform.cjs.js"),require("./WebGPUUniform.cjs.js"),require("./WebGPUSampler.cjs.js"),require("./WebGPUSampledTexture.cjs.js"),require("../nodes/core/NodeSlot.cjs.js"),require("../nodes/core/NodeBuilder.cjs.js"),require("../nodes/core/NodeUniform.cjs.js"),require("../nodes/core/NodeAttribute.cjs.js"),require("../nodes/core/NodeVary.cjs.js"),require("../nodes/core/constants.cjs.js"),require("../nodes/accessors/ModelViewProjectionNode.cjs.js"),require("../nodes/core/Node.cjs.js"),require("../nodes/accessors/CameraNode.cjs.js"),require("@babel/runtime/helpers/defineProperty"),require("../nodes/inputs/Vector3Node.cjs.js"),require("../nodes/core/InputNode.cjs.js"),require("../nodes/inputs/Matrix4Node.cjs.js"),require("../nodes/accessors/ModelNode.cjs.js"),require("../nodes/inputs/Matrix3Node.cjs.js"),require("../nodes/math/OperatorNode.cjs.js"),require("../nodes/accessors/PositionNode.cjs.js"),require("../nodes/core/AttributeNode.cjs.js"),require("./nodes/ShaderLib.cjs.js"),require("../nodes/core/NodeFrame.cjs.js");var f=m(p);console.info("THREE.WebGPURenderer: Modified Matrix4.makePerspective() and Matrix4.makeOrtographic() to work with WebGPU, see https://github.com/mrdoob/three.js/issues/20276."),_.Matrix4.prototype.makePerspective=function(e,t,s,i,r,o){const n=this.elements,h=2*r/(t-e),a=2*r/(s-i),l=(t+e)/(t-e),u=(s+i)/(s-i),c=-o/(o-r),d=-o*r/(o-r);return n[0]=h,n[4]=0,n[8]=l,n[12]=0,n[1]=0,n[5]=a,n[9]=u,n[13]=0,n[2]=0,n[6]=0,n[10]=c,n[14]=d,n[3]=0,n[7]=0,n[11]=-1,n[15]=0,this},_.Matrix4.prototype.makeOrthographic=function(e,t,s,i,r,o){const n=this.elements,h=1/(t-e),a=1/(s-i),l=1/(o-r),u=(t+e)*h,c=(s+i)*a,d=r*l;return n[0]=2*h,n[4]=0,n[8]=0,n[12]=-u,n[1]=0,n[5]=2*a,n[9]=0,n[13]=-c,n[2]=0,n[6]=0,n[10]=-1*l,n[14]=-d,n[3]=0,n[7]=0,n[11]=0,n[15]=1,this};const j=new _.Frustum,g=new _.Matrix4,x=new _.Vector3;module.exports=class{constructor(e={}){this.domElement=void 0!==e.canvas?e.canvas:this._createCanvasElement(),this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this._parameters=Object.assign({},e),this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=null,this._scissor=null,this._adapter=null,this._device=null,this._context=null,this._swapChain=null,this._colorBuffer=null,this._depthBuffer=null,this._info=null,this._properties=null,this._attributes=null,this._geometries=null,this._nodes=null,this._bindings=null,this._objects=null,this._renderPipelines=null,this._computePipelines=null,this._renderLists=null,this._textures=null,this._background=null,this._renderPassDescriptor=null,this._currentRenderList=null,this._opaqueSort=null,this._transparentSort=null,this._clearAlpha=1,this._clearColor=new _.Color(0),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._parameters.antialias=!0===e.antialias,!0===this._parameters.antialias?this._parameters.sampleCount=void 0===e.sampleCount?4:e.sampleCount:this._parameters.sampleCount=1,this._parameters.extensions=void 0===e.extensions?[]:e.extensions,this._parameters.limits=void 0===e.limits?{}:e.limits}async init(){const p=this._parameters,_={powerPreference:p.powerPreference},m=await navigator.gpu.requestAdapter(_),j={extensions:p.extensions,limits:p.limits},g=await m.requestDevice(j),x=await f.default(),b=void 0!==p.context?p.context:this.domElement.getContext("gpupresent"),w=b.configureSwapChain({device:g,format:e.GPUTextureFormat.BRGA8Unorm});this._adapter=m,this._device=g,this._context=b,this._swapChain=w,this._info=new r,this._properties=new o,this._attributes=new s(g),this._geometries=new i(this._attributes,this._info),this._textures=new u(g,this._properties,this._info,x),this._objects=new t(this._geometries,this._info),this._nodes=new d(this),this._renderPipelines=new n(this,this._properties,g,x,p.sampleCount,this._nodes),this._computePipelines=new h(g,x),this._bindings=new a(g,this._info,this._properties,this._textures,this._renderPipelines,this._computePipelines,this._attributes,this._nodes),this._renderLists=new l,this._background=new c(this),this._renderPassDescriptor={colorAttachments:[{attachment:null}],depthStencilAttachment:{attachment:null,depthStoreOp:e.GPUStoreOp.Store,stencilStoreOp:e.GPUStoreOp.Store}},this._setupColorBuffer(),this._setupDepthBuffer()}render(e,t){this._nodes.updateFrame(),!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===this._info.autoReset&&this._info.reset(),g.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),j.setFromProjectionMatrix(g),this._currentRenderList=this._renderLists.get(e,t),this._currentRenderList.init(),this._projectObject(e,t,0),this._currentRenderList.finish(),!0===this.sortObjects&&this._currentRenderList.sort(this._opaqueSort,this._transparentSort);const s=this._renderPassDescriptor.colorAttachments[0],i=this._renderPassDescriptor.depthStencilAttachment,r=this._renderTarget;if(null!==r){const e=this._properties.get(r);s.attachment=e.colorTextureGPU.createView(),i.attachment=e.depthTextureGPU.createView()}else!0===this._parameters.antialias?(s.attachment=this._colorBuffer.createView(),s.resolveTarget=this._swapChain.getCurrentTexture().createView()):(s.attachment=this._swapChain.getCurrentTexture().createView(),s.resolveTarget=void 0),i.attachment=this._depthBuffer.createView();this._background.update(e);const o=this._device,n=o.createCommandEncoder({}),h=n.beginRenderPass(this._renderPassDescriptor),a=this._viewport;if(null!==a){const e=Math.floor(a.width*this._pixelRatio),t=Math.floor(a.height*this._pixelRatio);h.setViewport(a.x,a.y,e,t,a.minDepth,a.maxDepth)}const l=this._scissor;if(null!==l){const e=Math.floor(l.width*this._pixelRatio),t=Math.floor(l.height*this._pixelRatio);h.setScissorRect(l.x,l.y,e,t)}const u=this._currentRenderList.opaque,c=this._currentRenderList.transparent;u.length>0&&this._renderObjects(u,t,h),c.length>0&&this._renderObjects(c,t,h),h.endPass(),o.queue.submit([n.finish()])}getContext(){return this._context}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio=e,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(e,t,s){this._width=e,this._height=t,this._pixelRatio=s,this.domElement.width=Math.floor(e*s),this.domElement.height=Math.floor(t*s),this._setupColorBuffer(),this._setupDepthBuffer()}setSize(e,t,s=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===s&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this._setupColorBuffer(),this._setupDepthBuffer()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,s,i){this._scissor=null===e?null:{x:e,y:t,width:s,height:i}}getViewport(e){const t=this._viewport;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e.minDepth=t.minDepth,e.maxDepth=t.maxDepth,e}setViewport(e,t,s,i,r=0,o=1){this._viewport=null===e?null:{x:e,y:t,width:s,height:i,minDepth:r,maxDepth:o}}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearAlpha=t}getClearAlpha(){return this._clearAlpha}setClearAlpha(e){this._clearAlpha=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}clear(){this._background.clear()}dispose(){this._objects.dispose(),this._properties.dispose(),this._renderPipelines.dispose(),this._computePipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._info.dispose(),this._renderLists.dispose(),this._textures.dispose()}setRenderTarget(e){this._renderTarget=e,null!==e&&this._textures.initRenderTarget(e)}compute(e){const t=this._device,s=t.createCommandEncoder({}),i=s.beginComputePass();for(let t of e){const e=this._computePipelines.get(t);i.setPipeline(e);const s=this._bindings.getForCompute(t).group;this._bindings.update(t),i.setBindGroup(0,s),i.dispatch(t.num)}i.endPass(),t.queue.submit([s.finish()])}getRenderTarget(){return this._renderTarget}_projectObject(e,t,s){const i=this._info,r=this._currentRenderList;if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)s=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)e.castShadow;else if(e.isSprite){if(!e.frustumCulled||j.intersectsSprite(e)){!0===this.sortObjects&&x.setFromMatrixPosition(e.matrixWorld).applyMatrix4(g);const t=e.geometry,i=e.material;i.visible&&r.push(e,t,i,s,x.z,null)}}else if(e.isLineLoop)console.error("THREE.WebGPURenderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==i.render.frame&&(e.skeleton.update(),e.skeleton.frame=i.render.frame),!e.frustumCulled||j.intersectsObject(e))){!0===this.sortObjects&&x.setFromMatrixPosition(e.matrixWorld).applyMatrix4(g);const t=e.geometry,i=e.material;if(Array.isArray(i)){const o=t.groups;for(let n=0,h=o.length;n<h;n++){const h=o[n],a=i[h.materialIndex];a&&a.visible&&r.push(e,t,a,s,x.z,h)}}else i.visible&&r.push(e,t,i,s,x.z,null)}const o=e.children;for(let e=0,i=o.length;e<i;e++)this._projectObject(o[e],t,s)}_renderObjects(e,t,s){for(let i=0,r=e.length;i<r;i++){const r=e[i].object;if(r.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,r.matrixWorld),r.normalMatrix.getNormalMatrix(r.modelViewMatrix),this._objects.update(r),t.isArrayCamera){const e=t.cameras;for(let t=0,i=e.length;t<i;t++){const i=e[t];if(r.layers.test(i.layers)){const e=i.viewport,t=void 0===e.minDepth?0:e.minDepth,o=void 0===e.maxDepth?1:e.maxDepth;s.setViewport(e.x,e.y,e.width,e.height,t,o),this._nodes.update(r,i),this._bindings.update(r,i),this._renderObject(r,s)}}}else this._nodes.update(r,t),this._bindings.update(r,t),this._renderObject(r,s)}}_renderObject(e,t){const s=this._info,i=this._renderPipelines.get(e);t.setPipeline(i);const r=this._bindings.get(e).group;t.setBindGroup(0,r);const o=e.geometry,n=o.index,h=null!==n;!0===h&&this._setupIndexBuffer(n,t),this._setupVertexBuffers(o.attributes,t,i);const a=o.drawRange,l=a.start,u=o.isInstancedBufferGeometry?o.instanceCount:1;if(!0===h){const i=a.count!==1/0?a.count:n.count;t.drawIndexed(i,u,l,0,0),s.update(e,i,u)}else{const i=o.attributes.position,r=a.count!==1/0?a.count:i.count;t.draw(r,u,l,0),s.update(e,r,u)}}_setupIndexBuffer(t,s){const i=this._attributes.get(t).buffer,r=t.array instanceof Uint16Array?e.GPUIndexFormat.Uint16:e.GPUIndexFormat.Uint32;s.setIndexBuffer(i,r)}_setupVertexBuffers(e,t,s){const i=this._renderPipelines.getShaderAttributes(s);for(let s of i){const i=s.name,r=s.slot,o=e[i];if(void 0!==o){const e=this._attributes.get(o).buffer;t.setVertexBuffer(r,e)}}}_setupColorBuffer(){this._device&&(this._colorBuffer&&this._colorBuffer.destroy(),this._colorBuffer=this._device.createTexture({size:{width:this._width*this._pixelRatio,height:this._height*this._pixelRatio,depthOrArrayLayers:1},sampleCount:this._parameters.sampleCount,format:e.GPUTextureFormat.BRGA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT}))}_setupDepthBuffer(){this._device&&(this._depthBuffer&&this._depthBuffer.destroy(),this._depthBuffer=this._device.createTexture({size:{width:this._width*this._pixelRatio,height:this._height*this._pixelRatio,depthOrArrayLayers:1},sampleCount:this._parameters.sampleCount,format:e.GPUTextureFormat.Depth24PlusStencil8,usage:GPUTextureUsage.RENDER_ATTACHMENT}))}_createCanvasElement(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}};
