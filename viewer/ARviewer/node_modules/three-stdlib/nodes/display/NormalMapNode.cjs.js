"use strict";var e=require("../core/TempNode.cjs.js"),r=require("../accessors/ModelNode.cjs.js"),s=require("../ShaderNode.cjs.js"),o=require("three");require("../core/Node.cjs.js"),require("../core/constants.cjs.js"),require("../core/NodeUtils.cjs.js"),require("../accessors/Object3DNode.cjs.js"),require("@babel/runtime/helpers/defineProperty"),require("../core/UniformNode.cjs.js"),require("../core/InputNode.cjs.js"),require("../core/PropertyNode.cjs.js"),require("../core/VarNode.cjs.js"),require("../core/AttributeNode.cjs.js"),require("../core/VaryNode.cjs.js"),require("../core/ConstNode.cjs.js"),require("../accessors/BufferNode.cjs.js"),require("../accessors/PositionNode.cjs.js"),require("../math/MathNode.cjs.js"),require("../core/ExpressionNode.cjs.js"),require("../utils/JoinNode.cjs.js"),require("../utils/SplitNode.cjs.js"),require("../core/NodeBuilder.cjs.js"),require("../core/NodeUniform.cjs.js"),require("../core/NodeAttribute.cjs.js"),require("../core/NodeVary.cjs.js"),require("../core/NodeVar.cjs.js"),require("../core/NodeCode.cjs.js"),require("../core/NodeKeywords.cjs.js"),require("../math/OperatorNode.cjs.js"),require("../accessors/NormalNode.cjs.js"),require("../accessors/CameraNode.cjs.js"),require("../accessors/TextureNode.cjs.js"),require("../accessors/UVNode.cjs.js"),require("../math/CondNode.cjs.js"),require("../core/ContextNode.cjs.js"),require("../utils/ArrayElementNode.cjs.js"),require("../utils/ConvertNode.cjs.js");const c=new s.ShaderNode((e=>{const{eye_pos:r,surf_norm:o,mapN:c,faceDirection:u,uv:i}=e,j=s.dFdx(r.xyz),d=s.dFdy(r.xyz),t=s.dFdx(i.st),a=s.dFdy(i.st),n=o,N=s.cross(d,n),l=s.cross(n,j),q=s.add(s.mul(N,t.x),s.mul(l,a.x)),m=s.add(s.mul(N,t.y),s.mul(l,a.y)),p=s.max(s.dot(q,q),s.dot(m,m)),y=s.cond(s.equal(p,0),0,s.mul(u,s.inversesqrt(p)));return s.normalize(s.add(s.mul(q,s.mul(c.x,y)),s.mul(m,s.mul(c.y,y)),s.mul(n,c.z)))}));module.exports=class extends e{constructor(e,r=null){super("vec3"),this.node=e,this.scaleNode=r,this.normalMapType=o.TangentSpaceNormalMap}generate(e){const u=this.getNodeType(e),{normalMapType:i,scaleNode:j}=this,d=s.mul(this.node,2);let t=s.sub(d,1);if(null!==j){const e=s.mul(t.xy,j);t=s.join(e,t.z)}if(i===o.ObjectSpaceNormalMap){const o=s.mul(new r(r.NORMAL_MATRIX),t);return s.normalize(o).build(e,u)}if(i===o.TangentSpaceNormalMap){return c({eye_pos:s.positionView,surf_norm:s.normalView,mapN:t,faceDirection:1,uv:s.uv()}).build(e,u)}}};
