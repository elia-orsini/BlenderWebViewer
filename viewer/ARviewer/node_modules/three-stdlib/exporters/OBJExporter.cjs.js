"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),e=require("three");function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var r=i(t);exports.OBJExporter=class{constructor(){r.default(this,"output",void 0),r.default(this,"indexVertex",void 0),r.default(this,"indexVertexUvs",void 0),r.default(this,"indexNormals",void 0),r.default(this,"vertex",void 0),r.default(this,"color",void 0),r.default(this,"normal",void 0),r.default(this,"uv",void 0),r.default(this,"face",void 0),this.output="",this.indexVertex=0,this.indexVertexUvs=0,this.indexNormals=0,this.vertex=new e.Vector3,this.color=new e.Color,this.normal=new e.Vector3,this.uv=new e.Vector2,this.face=[]}parse(t){return t.traverse((t=>{t instanceof e.Mesh&&t.isMesh&&this.parseMesh(t),t instanceof e.Line&&t.isLine&&this.parseLine(t),t instanceof e.Points&&t.isPoints&&this.parsePoints(t)})),this.output}parseMesh(t){let i=0,r=0,o=0;const s=t.geometry,n=new e.Matrix3;if(!s.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const h=s.getAttribute("position"),u=s.getAttribute("normal"),x=s.getAttribute("uv"),a=s.getIndex();if(this.output+=`o ${t.name}\n`,t.material&&!Array.isArray(t.material)&&t.material.name&&(this.output+=`usemtl ${t.material.name}\n`),void 0!==h)for(let e=0,r=h.count;e<r;e++,i++)this.vertex.x=h.getX(e),this.vertex.y=h.getY(e),this.vertex.z=h.getZ(e),this.vertex.applyMatrix4(t.matrixWorld),this.output+=`v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;if(void 0!==x)for(let t=0,e=x.count;t<e;t++,o++)this.uv.x=x.getX(t),this.uv.y=x.getY(t),this.output+=`vt ${this.uv.x} ${this.uv.y}\n`;if(void 0!==u){n.getNormalMatrix(t.matrixWorld);for(let t=0,e=u.count;t<e;t++,r++)this.normal.x=u.getX(t),this.normal.y=u.getY(t),this.normal.z=u.getZ(t),this.normal.applyMatrix3(n).normalize(),this.output+=`vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`}if(null!==a)for(let t=0,e=a.count;t<e;t+=3){for(let e=0;e<3;e++){const i=a.getX(t+e)+1;this.face[e]=this.indexVertex+i+(u||x?`/${x?this.indexVertexUvs+i:""}${u?`/${this.indexNormals+i}`:""}`:"")}this.output+=`f ${this.face.join(" ")}\n`}else for(let t=0,e=h.count;t<e;t+=3){for(let e=0;e<3;e++){const i=t+e+1;this.face[e]=this.indexVertex+i+(u||x?`/${x?this.indexVertexUvs+i:""}${u?`/${this.indexNormals+i}`:""}`:"")}this.output+=`f ${this.face.join(" ")}\n`}this.indexVertex+=i,this.indexVertexUvs+=o,this.indexNormals+=r}parseLine(t){let e=0;const i=t.geometry,r=t.type;if(i.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const o=i.getAttribute("position");if(this.output+=`o ${t.name}\n`,void 0!==o)for(let i=0,r=o.count;i<r;i++,e++)this.vertex.x=o.getX(i),this.vertex.y=o.getY(i),this.vertex.z=o.getZ(i),this.vertex.applyMatrix4(t.matrixWorld),this.output+=`v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;if("Line"===r){this.output+="l ";for(let t=1,e=o.count;t<=e;t++)this.output+=`${this.indexVertex+t} `;this.output+="\n"}if("LineSegments"===r)for(let t=1,e=t+1,i=o.count;t<i;t+=2,e=t+1)this.output+=`l ${this.indexVertex+t} ${this.indexVertex+e}\n`;this.indexVertex+=e}parsePoints(t){let i=0;const r=t.geometry;if(!r.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const o=r.getAttribute("position"),s=r.getAttribute("color");if(this.output+=`o ${t.name}\n`,void 0!==o)for(let r=0,n=o.count;r<n;r++,i++)this.vertex.fromBufferAttribute(o,r),this.vertex.applyMatrix4(t.matrixWorld),this.output+=`v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`,void 0!==s&&s instanceof e.BufferAttribute&&(this.color.fromBufferAttribute(s,r),this.output+=` ${this.color.r} ${this.color.g} ${this.color.b}`),this.output+="\n";this.output+="p ";for(let t=1,e=o.count;t<=e;t++)this.output+=`${this.indexVertex+t} `;this.output+="\n",this.indexVertex+=i}};
