"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),e=require("three");function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var s=i(t);exports.STLExporter=class{constructor(){s.default(this,"binary",void 0),s.default(this,"output",void 0),s.default(this,"offset",void 0),s.default(this,"objects",void 0),s.default(this,"triangles",void 0),s.default(this,"vA",void 0),s.default(this,"vB",void 0),s.default(this,"vC",void 0),s.default(this,"cb",void 0),s.default(this,"ab",void 0),s.default(this,"normal",void 0),this.binary=!1,this.output="",this.offset=80,this.objects=[],this.triangles=0,this.vA=new e.Vector3,this.vB=new e.Vector3,this.vC=new e.Vector3,this.cb=new e.Vector3,this.ab=new e.Vector3,this.normal=new e.Vector3}parse(t,i){if(this.binary=void 0!==i.binary&&i.binary,t.traverse((t=>{if(t instanceof e.Mesh&&t.isMesh){const e=t.geometry;if(!e.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const i=e.index,s=e.getAttribute("position");this.triangles+=null!==i?i.count/3:s.count/3,this.objects.push({object3d:t,geometry:e})}})),this.binary){const t=2*this.triangles+3*this.triangles*4*4+80+4,e=new ArrayBuffer(t);this.output=new DataView(e),this.output.setUint32(this.offset,this.triangles,!0),this.offset+=4}else this.output="",this.output+="solid exported\n";for(let t=0,i=this.objects.length;t<i;t++){const i=this.objects[t].object3d,s=this.objects[t].geometry,o=s.index,r=s.getAttribute("position");if(i instanceof e.SkinnedMesh)if(null!==o)for(let t=0;t<o.count;t+=3){const e=o.getX(t+0),s=o.getX(t+1),h=o.getX(t+2);this.writeFace(e,s,h,r,i)}else for(let t=0;t<r.count;t+=3){const e=t+0,s=t+1,o=t+2;this.writeFace(e,s,o,r,i)}}return this.binary||(this.output+="endsolid exported\n"),this.output}writeFace(t,e,i,s,o){this.vA.fromBufferAttribute(s,t),this.vB.fromBufferAttribute(s,e),this.vC.fromBufferAttribute(s,i),o.isSkinnedMesh&&(o.boneTransform(t,this.vA),o.boneTransform(e,this.vB),o.boneTransform(i,this.vC)),this.vA.applyMatrix4(o.matrixWorld),this.vB.applyMatrix4(o.matrixWorld),this.vC.applyMatrix4(o.matrixWorld),this.writeNormal(this.vA,this.vB,this.vC),this.writeVertex(this.vA),this.writeVertex(this.vB),this.writeVertex(this.vC),this.binary&&this.output instanceof DataView?(this.output.setUint16(this.offset,0,!0),this.offset+=2):(this.output+="\t\tendloop\n",this.output+="\tendfacet\n")}writeNormal(t,e,i){this.cb.subVectors(i,e),this.ab.subVectors(t,e),this.cb.cross(this.ab).normalize(),this.normal.copy(this.cb).normalize(),this.binary&&this.output instanceof DataView?(this.output.setFloat32(this.offset,this.normal.x,!0),this.offset+=4,this.output.setFloat32(this.offset,this.normal.y,!0),this.offset+=4,this.output.setFloat32(this.offset,this.normal.z,!0),this.offset+=4):(this.output+=`\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`,this.output+="\t\touter loop\n")}writeVertex(t){this.binary&&this.output instanceof DataView?(this.output.setFloat32(this.offset,t.x,!0),this.offset+=4,this.output.setFloat32(this.offset,t.y,!0),this.offset+=4,this.output.setFloat32(this.offset,t.z,!0),this.offset+=4):this.output+="\t\t\tvertex vertex.x vertex.y vertex.z\n"}};
