"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/defineProperty"),t=require("three");function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=o(e);class n{parse(e,o={decodeSpeed:5,encodeSpeed:5,encoderMethod:n.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1}){if(e instanceof t.BufferGeometry&&e.isBufferGeometry)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");const r=e.geometry,i=DracoEncoderModule(),d=new i.Encoder;let a,s;if(!r.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");if(e instanceof t.Mesh&&e.isMesh){a=new i.MeshBuilder,s=new i.Mesh;const e=r.getAttribute("position");a.AddFloatAttributeToMesh(s,i.POSITION,e.count,e.itemSize,e.array);const t=r.getIndex();if(null!==t)a.AddFacesToMesh(s,t.count/3,t.array);else{const t=new(e.count>65535?Uint32Array:Uint16Array)(e.count);for(let e=0;e<t.length;e++)t[e]=e;a.AddFacesToMesh(s,e.count,t)}if(o.exportNormals){const e=r.getAttribute("normal");void 0!==e&&a.AddFloatAttributeToMesh(s,i.NORMAL,e.count,e.itemSize,e.array)}if(o.exportUvs){const e=r.getAttribute("uv");void 0!==e&&a.AddFloatAttributeToMesh(s,i.TEX_COORD,e.count,e.itemSize,e.array)}if(o.exportColor){const e=r.getAttribute("color");void 0!==e&&a.AddFloatAttributeToMesh(s,i.COLOR,e.count,e.itemSize,e.array)}}else{if(!(e instanceof t.Points&&e.isPoints))throw new Error("DRACOExporter: Unsupported object type.");{a=new i.PointCloudBuilder,s=new i.PointCloud;const e=r.getAttribute("position");if(a.AddFloatAttribute(s,i.POSITION,e.count,e.itemSize,e.array),o.exportColor){const e=r.getAttribute("color");void 0!==e&&a.AddFloatAttribute(s,i.COLOR,e.count,e.itemSize,e.array)}}}const u=new i.DracoInt8Array,c=void 0!==o.encodeSpeed?o.encodeSpeed:5,f=void 0!==o.decodeSpeed?o.decodeSpeed:5;if(d.SetSpeedOptions(c,f),void 0!==o.encoderMethod&&d.SetEncodingMethod(o.encoderMethod),void 0!==o.quantization)for(let e=0;e<5;e++)void 0!==o.quantization[e]&&d.SetAttributeQuantization(e,o.quantization[e]);let l;if(l=e instanceof t.Mesh&&e.isMesh?d.EncodeMeshToDracoBuffer(s,u):d.EncodePointCloudToDracoBuffer(s,!0,u),i.destroy(s),0===l)throw new Error("THREE.DRACOExporter: Draco encoding failed.");const E=new Int8Array(new ArrayBuffer(l));for(let e=0;e<l;e++)E[e]=u.GetValue(e);return i.destroy(u),i.destroy(d),i.destroy(a),E}}r.default(n,"MESH_EDGEBREAKER_ENCODING",1),r.default(n,"MESH_SEQUENTIAL_ENCODING",0),r.default(n,"POINT_CLOUD",0),r.default(n,"TRIANGULAR_MESH",1),r.default(n,"INVALID",-1),r.default(n,"POSITION",0),r.default(n,"NORMAL",1),r.default(n,"COLOR",2),r.default(n,"TEX_COORD",3),r.default(n,"GENERIC",4),exports.DRACOExporter=n;
