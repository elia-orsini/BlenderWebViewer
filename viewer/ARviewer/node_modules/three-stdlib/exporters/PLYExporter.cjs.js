"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");exports.PLYExporter=class{parse(e,n,r){n&&"object"==typeof n&&(console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.'),r=n,n=void 0);const i=(r=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},r)).excludeAttributes;let o=!1,l=!1,a=!1,s=0,u=0;e.traverse((function(e){if(e instanceof t.Mesh&&e.isMesh){const t=e.geometry;if(!t.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");const n=t.getAttribute("position"),r=t.getAttribute("normal"),i=t.getAttribute("uv"),f=t.getAttribute("color"),d=t.getIndex();if(void 0===n)return;s+=n.count,u+=d?d.count/3:n.count/3,void 0!==r&&(o=!0),void 0!==i&&(a=!0),void 0!==f&&(l=!0)}}));const f=-1===(null==i?void 0:i.indexOf("index"));if(o=o&&-1===(null==i?void 0:i.indexOf("normal")),l=l&&-1===(null==i?void 0:i.indexOf("color")),a=a&&-1===(null==i?void 0:i.indexOf("uv")),f&&u!==Math.floor(u))return console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."),null;let d=`ply\nformat ${r.binary?r.littleEndian?"binary_little_endian":"binary_big_endian":"ascii"} 1.0\nelement vertex ${s}\nproperty float x\nproperty float y\nproperty float z\n`;o&&(d+="property float nx\nproperty float ny\nproperty float nz\n"),a&&(d+="property float s\nproperty float t\n"),l&&(d+="property uchar red\nproperty uchar green\nproperty uchar blue\n"),f&&(d+=`element face ${u}\nproperty list uchar int vertex_index\n`),d+="end_header\n";const g=new t.Vector3,c=new t.Matrix3;let p=null;if(r.binary){const t=(new TextEncoder).encode(d),n=s*(12+(o?12:0)+(l?3:0)+(a?8:0)),i=f?13*u:0,y=new DataView(new ArrayBuffer(t.length+n+i));new Uint8Array(y.buffer).set(t,0);let x=t.length,E=t.length+n,h=0;this.traverseMeshes(e,(function(t,e){const n=e.getAttribute("position"),i=e.getAttribute("normal"),s=e.getAttribute("uv"),u=e.getAttribute("color"),d=e.getIndex();c.getNormalMatrix(t.matrixWorld);for(let e=0,f=n.count;e<f;e++)g.x=n.getX(e),g.y=n.getY(e),g.z=n.getZ(e),g.applyMatrix4(t.matrixWorld),y.setFloat32(x,g.x,r.littleEndian),x+=4,y.setFloat32(x,g.y,r.littleEndian),x+=4,y.setFloat32(x,g.z,r.littleEndian),x+=4,o&&(null!=i?(g.x=i.getX(e),g.y=i.getY(e),g.z=i.getZ(e),g.applyMatrix3(c).normalize(),y.setFloat32(x,g.x,r.littleEndian),x+=4,y.setFloat32(x,g.y,r.littleEndian),x+=4,y.setFloat32(x,g.z,r.littleEndian),x+=4):(y.setFloat32(x,0,r.littleEndian),x+=4,y.setFloat32(x,0,r.littleEndian),x+=4,y.setFloat32(x,0,r.littleEndian),x+=4)),a&&(null!=s?(y.setFloat32(x,s.getX(e),r.littleEndian),x+=4,y.setFloat32(x,s.getY(e),r.littleEndian),x+=4):a||(y.setFloat32(x,0,r.littleEndian),x+=4,y.setFloat32(x,0,r.littleEndian),x+=4)),l&&(null!=u?(y.setUint8(x,Math.floor(255*u.getX(e))),x+=1,y.setUint8(x,Math.floor(255*u.getY(e))),x+=1,y.setUint8(x,Math.floor(255*u.getZ(e))),x+=1):(y.setUint8(x,255),x+=1,y.setUint8(x,255),x+=1,y.setUint8(x,255),x+=1));if(f)if(null!==d)for(let t=0,e=d.count;t<e;t+=3)y.setUint8(E,3),E+=1,y.setUint32(E,d.getX(t+0)+h,r.littleEndian),E+=4,y.setUint32(E,d.getX(t+1)+h,r.littleEndian),E+=4,y.setUint32(E,d.getX(t+2)+h,r.littleEndian),E+=4;else for(let t=0,e=n.count;t<e;t+=3)y.setUint8(E,3),E+=1,y.setUint32(E,h+t,r.littleEndian),E+=4,y.setUint32(E,h+t+1,r.littleEndian),E+=4,y.setUint32(E,h+t+2,r.littleEndian),E+=4;h+=n.count})),p=y.buffer}else{let t=0,n="",r="";this.traverseMeshes(e,(function(e,i){const s=i.getAttribute("position"),d=i.getAttribute("normal"),p=i.getAttribute("uv"),y=i.getAttribute("color"),x=i.getIndex();c.getNormalMatrix(e.matrixWorld);for(let t=0,r=s.count;t<r;t++){g.x=s.getX(t),g.y=s.getY(t),g.z=s.getZ(t),g.applyMatrix4(e.matrixWorld);let r=g.x+" "+g.y+" "+g.z;o&&(null!=d?(g.x=d.getX(t),g.y=d.getY(t),g.z=d.getZ(t),g.applyMatrix3(c).normalize(),r+=" "+g.x+" "+g.y+" "+g.z):r+=" 0 0 0"),a&&(null!=p?r+=" "+p.getX(t)+" "+p.getY(t):a&&(r+=" 0 0")),l&&(r+=null!=y?" "+Math.floor(255*y.getX(t))+" "+Math.floor(255*y.getY(t))+" "+Math.floor(255*y.getZ(t)):" 255 255 255"),n+=r+"\n"}if(f){if(null!==x)for(let e=0,n=x.count;e<n;e+=3)r+=`3 ${x.getX(e+0)+t}`,r+=` ${x.getX(e+1)+t}`,r+=` ${x.getX(e+2)+t}\n`;else for(let e=0,n=s.count;e<n;e+=3)r+=`3 ${t+e} ${t+e+1} ${t+e+2}\n`;u+=x?x.count/3:s.count/3}t+=s.count})),p=`${d}${n}${f?`${r}\n`:"\n"}`}return"function"==typeof n&&requestAnimationFrame((()=>n&&n("string"==typeof p?p:""))),p}traverseMeshes(e,n){e.traverse((function(e){if(e instanceof t.Mesh&&e.isMesh){const t=e,r=t.geometry;if(!r.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");r.hasAttribute("position")&&n(t,r)}}))}};
