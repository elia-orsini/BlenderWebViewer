"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/defineProperty"),t=require("three");function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=s(e);class i{constructor(){n.default(this,"pluginCallbacks",void 0),this.pluginCallbacks=[],this.register((function(e){return new I(e)})),this.register((function(e){return new R(e)})),this.register((function(e){return new F(e)})),this.register((function(e){return new N(e)})),this.register((function(e){return new B(e)}))}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s){const n=new E,i=[];for(let e=0,t=this.pluginCallbacks.length;e<t;e++)i.push(this.pluginCallbacks[e](n));n.setPlugins(i),n.write(e,t,s)}}n.default(i,"Utils",{insertKeyframe:function(e,t){const s=.001,n=e.getValueSize(),i=new e.TimeBufferType(e.times.length+1),r=new e.ValueBufferType(e.values.length+n),a=e.createInterpolant(new e.ValueBufferType(n));let o;if(0===e.times.length){i[0]=t;for(let e=0;e<n;e++)r[e]=0;o=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<s)return 0;i[0]=t,i.set(e.times,1),r.set(a.evaluate(t),0),r.set(e.values,n),o=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<s)return e.times.length-1;i[i.length-1]=t,i.set(e.times,0),r.set(e.values,0),r.set(a.evaluate(t),e.values.length),o=i.length-1}else for(let l=0;l<e.times.length;l++){if(Math.abs(e.times[l]-t)<s)return l;if(e.times[l]<t&&e.times[l+1]>t){i.set(e.times.slice(0,l+1),0),i[l+1]=t,i.set(e.times.slice(l+1),l+2),r.set(e.values.slice(0,(l+1)*n),0),r.set(a.evaluate(t),(l+1)*n),r.set(e.values.slice((l+1)*n),(l+2)*n),o=l+1;break}}return e.times=i,e.values=r,o},mergeMorphTargetTracks:function(e,s){const n=[],i={},r=e.tracks;for(let e=0;e<r.length;++e){let a=r[e];const o=t.PropertyBinding.parseTrackName(a.name),l=t.PropertyBinding.findNode(s,o.nodeName);if("morphTargetInfluences"!==o.propertyName||void 0===o.propertyIndex){n.push(a);continue}if(a.createInterpolant!==a.InterpolantFactoryMethodDiscrete&&a.createInterpolant!==a.InterpolantFactoryMethodLinear){if(a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),a=a.clone(),a.setInterpolation(t.InterpolateLinear)}const c=l.morphTargetInfluences.length,h=l.morphTargetDictionary[o.propertyIndex];if(void 0===h)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let u;if(void 0===i[l.uuid]){u=a.clone();const e=new u.ValueBufferType(c*u.times.length);for(let t=0;t<u.times.length;t++)e[t*c+h]=u.values[t];u.name=(o.nodeName||"")+".morphTargetInfluences",u.values=e,i[l.uuid]=u,n.push(u);continue}const f=a.createInterpolant(new a.ValueBufferType(1));u=i[l.uuid];for(let e=0;e<u.times.length;e++)u.values[e*c+h]=f.evaluate(u.times[e]);for(let e=0;e<a.times.length;e++){const t=this.insertKeyframe(u,a.times[e]);u.values[t*c+h]=a.values[e]}}return e.tracks=n,e}});const r=0,a=1,o=2,l=3,c=4,h=5121,u=5123,f=5126,p=5125,m=34962,d=34963,g=9728,M=9729,y=9984,b=9985,x=9986,w=9987,T=33071,v=33648,A=10497,S={};S[t.NearestFilter]=g,S[t.NearestMipmapNearestFilter]=y,S[t.NearestMipmapLinearFilter]=x,S[t.LinearFilter]=M,S[t.LinearMipmapNearestFilter]=b,S[t.LinearMipmapLinearFilter]=w,S[t.ClampToEdgeWrapping]=T,S[t.RepeatWrapping]=A,S[t.MirroredRepeatWrapping]=v;const L={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};class E{constructor(){n.default(this,"plugins",void 0),n.default(this,"options",void 0),n.default(this,"pending",void 0),n.default(this,"buffers",void 0),n.default(this,"byteOffset",void 0),n.default(this,"nodeMap",void 0),n.default(this,"skins",void 0),n.default(this,"extensionsUsed",void 0),n.default(this,"uids",void 0),n.default(this,"uid",void 0),n.default(this,"json",void 0),n.default(this,"cache",void 0),n.default(this,"cachedCanvas",void 0),this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.cachedCanvas=null}setPlugins(e){this.plugins=e}write(e,t,s){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},s),void 0!==this.options.animations&&this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e);const n=this;Promise.all(this.pending).then((()=>{const e=n.buffers,s=n.json,i=n.options,r=n.extensionsUsed,a=new Blob(e,{type:"application/octet-stream"}),o=Object.keys(r);if(o.length>0&&(s.extensionsUsed=o),s.buffers&&s.buffers.length>0&&(s.buffers[0].byteLength=a.size),i.binary){const e=new window.FileReader;e.readAsArrayBuffer(a),e.onloadend=()=>{if(null!==e.result&&"string"!=typeof e.result){const n=this.getPaddedArrayBuffer(e.result),i=new DataView(new ArrayBuffer(8));i.setUint32(0,n.byteLength,!0),i.setUint32(4,5130562,!0);const r=this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(s)),32),a=new DataView(new ArrayBuffer(8));a.setUint32(0,r.byteLength,!0),a.setUint32(4,1313821514,!0);const o=new ArrayBuffer(12),l=new DataView(o);l.setUint32(0,1179937895,!0),l.setUint32(4,2,!0);const c=12+a.byteLength+r.byteLength+i.byteLength+n.byteLength;l.setUint32(8,c,!0);const h=new Blob([o,a,r,i,n],{type:"application/octet-stream"}),u=new window.FileReader;u.readAsArrayBuffer(h),u.onloadend=function(){null!==u.result&&"string"!=typeof u.result&&t(u.result)}}}}else if(s.buffers&&s.buffers.length>0){const e=new window.FileReader;e.readAsDataURL(a),e.onloadend=function(){const n=e.result;void 0!==s.buffers&&null!==n&&(s.buffers[0].uri=n,t(s))}}else t(s)}))}serializeUserData(e,t){if(0===Object.keys(e.userData).length)return;const s=this.options,n=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(e.userData));if(s.includeCustomExtensions&&i.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(const e in i.gltfExtensions)t.extensions[e]=i.gltfExtensions[e],n[e]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(t.extras=i)}catch(t){t instanceof Error&&console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}getUID(e){return this.uids.has(e)||this.uids.set(e,this.uid++),this.uids.get(e)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const s=new t.Vector3;for(let t=0,n=e.count;t<n;t++)if(Math.abs(s.fromBufferAttribute(e,t).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const s=this.cache;if(s.attributesNormalized.has(e))return s.attributesNormalized.get(e);const n=e.clone(),i=new t.Vector3;for(let e=0,t=n.count;e<t;e++)i.fromBufferAttribute(n,e),0===i.x&&0===i.y&&0===i.z?i.setX(1):i.normalize(),n.setXYZ(e,i.x,i.y,i.z);return s.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let s=!1;const n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),s=!0),0!==t.rotation&&(n.rotation=t.rotation,s=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),s=!0),s&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=n,this.extensionsUsed.KHR_texture_transform=!0)}processBuffer(e){const t=this.json,s=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),s.push(e),0}processBufferView(e,t,s,n,i){const r=this.json;let a;r.bufferViews||(r.bufferViews=[]),a=t===h?1:t===u?2:4;const o=this.getPaddedBufferSize(n*e.itemSize*a),l=new DataView(new ArrayBuffer(o));let c=0;for(let i=s;i<s+n;i++)for(let s=0;s<e.itemSize;s++){let n;e.itemSize>4?n=e.array[i*e.itemSize+s]:0===s?n=e.getX(i):1===s?n=e.getY(i):2===s?n=e.getZ(i):3===s&&(n=e.getW(i)),void 0!==n&&(t===f?l.setFloat32(c,n,!0):t===p?l.setUint32(c,n,!0):t===u?l.setUint16(c,n,!0):t===h&&l.setUint8(c,n)),c+=a}const d={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:o};void 0!==i&&(d.target=i),i===m&&(d.byteStride=e.itemSize*a),this.byteOffset+=o,r.bufferViews.push(d);return{id:r.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,s=t.json;return s.bufferViews||(s.bufferViews=[]),new Promise((n=>{const i=new window.FileReader;i.readAsArrayBuffer(e),i.onloadend=()=>{if(null!==i.result&&"string"!=typeof i.result&&void 0!==s.bufferViews){const e=this.getPaddedArrayBuffer(i.result),r={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,n(s.bufferViews.push(r)-1)}}}))}processAccessor(e,t,s,n){const i=this.options,r=this.json,a={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=f;else if(e.array.constructor===Uint32Array)o=p;else if(e.array.constructor===Uint16Array)o=u;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");o=h}if(void 0===s&&(s=0),void 0===n&&(n=e.count),i.truncateDrawRange&&void 0!==t&&null===t.index){const i=s+n,r=t.drawRange.count===1/0?e.count:t.drawRange.start+t.drawRange.count;s=Math.max(s,t.drawRange.start),(n=Math.min(i,r)-s)<0&&(n=0)}if(0===n)return null;const l=this.getMinMax(e,s,n);let c;if(void 0!==t&&(c=e===t.index?d:m),void 0!==c){const t=this.processBufferView(e,o,s,n,c),i={bufferView:t.id,byteOffset:t.byteOffset,componentType:o,count:n,max:l.max,min:l.min,type:a[e.itemSize]};return e.normalized&&(i.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(i)-1}}processImage(e,s,n){const i=this,r=i.cache,a=i.json,o=i.options,l=i.pending;r.images.has(e)||r.images.set(e,{});const c=r.images.get(e),h=s===t.RGBAFormat?"image/png":"image/jpeg",u=h+":flipY/"+n.toString();if(void 0!==c&&void 0!==c[u])return c[u];a.images||(a.images=[]);const f={mimeType:h};if(o.embedImages&&void 0!==o.maxTextureSize){const r=this.cachedCanvas=this.cachedCanvas||document.createElement("canvas");r.width=Math.min(e.width,o.maxTextureSize),r.height=Math.min(e.height,o.maxTextureSize);const a=r.getContext("2d");if(n&&(null==a||a.translate(0,r.height),null==a||a.scale(1,-1)),"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)null==a||a.drawImage(e,0,0,r.width,r.height);else{s!==t.RGBAFormat&&console.error("GLTFExporter: Only RGBA format is supported."),(e.width>o.maxTextureSize||e.height>o.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const n=new Uint8ClampedArray(e.height*e.width*4);if(e instanceof ImageData)for(let t=0;t<n.length;t+=4)n[t+0]=e.data[t+0],n[t+1]=e.data[t+1],n[t+2]=e.data[t+2],n[t+3]=e.data[t+3];null==a||a.putImageData(new ImageData(n,e.width,e.height),0,0)}o.binary?l.push(new Promise((function(e){r.toBlob((function(t){null!==t&&i.processBufferViewImage(t).then((function(t){f.bufferView=t,e()}))}),h)}))):f.uri=r.toDataURL(h)}else e instanceof Image&&(f.uri=e.src);const p=a.images.push(f)-1;return void 0!==c&&(c[u]=p),p}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const s={magFilter:S[e.magFilter],minFilter:S[e.minFilter],wrapS:S[e.wrapS],wrapT:S[e.wrapT]};return t.samplers.push(s)-1}processTexture(e){const t=this.cache,s=this.json;if(t.textures.has(e))return t.textures.get(e);s.textures||(s.textures=[]);const n={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY)};e.name&&(n.name=e.name),this._invokeAll((function(t){t.writeTexture&&t.writeTexture(e,n)}));const i=s.textures.push(n)-1;return t.textures.set(e,i),i}processMaterial(e){const s=this.cache,n=this.json;if(s.materials.has(e))return s.materials.get(e);if(e instanceof t.ShaderMaterial&&e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const i={pbrMetallicRoughness:{}};if(e instanceof t.MeshStandardMaterial&&e.isMeshStandardMaterial&&e instanceof t.MeshBasicMaterial&&e.isMeshBasicMaterial||console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."),e instanceof t.MeshStandardMaterial||e instanceof t.MeshPhysicalMaterial){const t=e.color.toArray().concat([e.opacity]);this.equalArray(t,[1,1,1,1])||(i.pbrMetallicRoughness.baseColorFactor=t)}if(e instanceof t.MeshStandardMaterial&&e.isMeshStandardMaterial?(i.pbrMetallicRoughness.metallicFactor=e.metalness,i.pbrMetallicRoughness.roughnessFactor=e.roughness):(i.pbrMetallicRoughness.metallicFactor=.5,i.pbrMetallicRoughness.roughnessFactor=.5),e instanceof t.MeshStandardMaterial&&e.metalnessMap||e instanceof t.MeshStandardMaterial&&e.roughnessMap)if(e.metalnessMap===e.roughnessMap&&null!==e.metalnessMap){const t={index:this.processTexture(e.metalnessMap)};this.applyTextureTransform(t,e.metalnessMap),i.pbrMetallicRoughness.metallicRoughnessTexture=t}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if((e instanceof t.MeshStandardMaterial||e instanceof t.MeshPhysicalMaterial)&&e.map){const t={index:this.processTexture(e.map)};this.applyTextureTransform(t,e.map),i.pbrMetallicRoughness.baseColorTexture=t}if((e instanceof t.MeshStandardMaterial||e instanceof t.MeshPhysicalMaterial)&&e.emissive){const t=e.emissive.clone().multiplyScalar(e.emissiveIntensity),s=Math.max(t.r,t.g,t.b);if(s>1&&(t.multiplyScalar(1/s),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),s>0&&(i.emissiveFactor=t.toArray()),e.emissiveMap){const t={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(t,e.emissiveMap),i.emissiveTexture=t}}if((e instanceof t.MeshMatcapMaterial||e instanceof t.MeshNormalMaterial||e instanceof t.MeshPhongMaterial||e instanceof t.MeshStandardMaterial||e instanceof t.MeshToonMaterial)&&e.normalMap){const t={index:this.processTexture(e.normalMap)};e.normalScale&&1!==e.normalScale.x&&(t.scale=e.normalScale.x),this.applyTextureTransform(t,e.normalMap),i.normalTexture=t}if((e instanceof t.MeshBasicMaterial||e instanceof t.MeshLambertMaterial||e instanceof t.MeshPhongMaterial||e instanceof t.MeshStandardMaterial||e instanceof t.MeshToonMaterial)&&e.aoMap){const t={index:this.processTexture(e.aoMap),texCoord:1};1!==e.aoMapIntensity&&(t.strength=e.aoMapIntensity),this.applyTextureTransform(t,e.aoMap),i.occlusionTexture=t}e.transparent?i.alphaMode="BLEND":e.alphaTest>0&&(i.alphaMode="MASK",i.alphaCutoff=e.alphaTest),e.side===t.DoubleSide&&(i.doubleSided=!0),""!==e.name&&(i.name=e.name),this.serializeUserData(e,i),this._invokeAll((function(t){t.writeMaterial&&t.writeMaterial(e,i)}));const r=n.materials.push(i)-1;return s.materials.set(e,r),r}processMesh(e){const s=this.cache,n=this.json,i=[e.geometry.uuid];if(Array.isArray(e.material))for(let t=0,s=e.material.length;t<s;t++)i.push(e.material[t].uuid);else i.push(e.material.uuid);const h=i.join(":");if(s.meshes.has(h))return s.meshes.get(h);const u=e.geometry;let f;if(f=e instanceof t.LineSegments&&e.isLineSegments?a:e instanceof t.LineLoop&&e.isLineLoop?o:e instanceof t.Line&&e.isLine?l:e instanceof t.Points&&e.isPoints?r:(e.material instanceof t.MeshBasicMaterial||e.material instanceof t.MeshDepthMaterial||e.material instanceof t.MeshLambertMaterial||e.material instanceof t.MeshNormalMaterial||e.material instanceof t.MeshPhongMaterial||e.material instanceof t.MeshStandardMaterial||e.material instanceof t.MeshToonMaterial||e.material instanceof t.ShaderMaterial)&&e.material.wireframe?a:c,!u.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const p={},m={},d=[],g=[],M={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},y=u.getAttribute("normal");void 0===y||y instanceof t.InterleavedBufferAttribute||this.isNormalizedNormalAttribute(y)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),u.setAttribute("normal",this.createNormalizedNormalAttribute(y)));let b=null;for(let e in u.attributes){if("morph"===e.substr(0,5))continue;const n=u.attributes[e];e=M[e]||e.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e)||(e="_"+e),s.attributes.has(this.getUID(n))){m[e]=s.attributes.get(this.getUID(n));continue}b=null;const i=n.array;"JOINTS_0"!==e||i instanceof Uint16Array||i instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),b=new t.BufferAttribute(new Uint16Array(i),n.itemSize,n.normalized));const r=null!==b&&this.processAccessor(b||n,u);r&&(m[e]=r,s.attributes.set(this.getUID(n),r))}if(void 0!==y&&u.setAttribute("normal",y),0===Object.keys(m).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){const t=[],n=[],i={};if(void 0!==e.morphTargetDictionary)for(const t in e.morphTargetDictionary)i[e.morphTargetDictionary[t]]=t;for(let r=0;r<e.morphTargetInfluences.length;++r){const a={};let o=!1;for(const e in u.morphAttributes){if("position"!==e&&"normal"!==e){o||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),o=!0);continue}const t=u.morphAttributes[e][r],n=e.toUpperCase(),i=u.attributes[e];if(s.attributes.has(this.getUID(t))){a[n]=s.attributes.get(this.getUID(t));continue}const l=t.clone();if(!u.morphTargetsRelative)for(let e=0,s=t.count;e<s;e++)l.setXYZ(e,t.getX(e)-i.getX(e),t.getY(e)-i.getY(e),t.getZ(e)-i.getZ(e));const c=this.processAccessor(l,u);null!=c&&(a[n]=c),s.attributes.set(this.getUID(i),a[n])}g.push(a),t.push(e.morphTargetInfluences[r]),void 0!==e.morphTargetDictionary&&n.push(i[r])}p.weights=t,n.length>0&&(p.extras={},p.extras.targetNames=n)}const x=Array.isArray(e.material);if(x&&0===u.groups.length)return null;const w=x?e.material:[e.material],T=x?u.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let e=0,n=T.length;e<n;e++){const n={mode:f,attributes:m};if((u instanceof t.Object3D||u instanceof t.Material)&&this.serializeUserData(u,n),g.length>0&&(n.targets=g),null!==u.index){let t=this.getUID(u.index);void 0===T[e].start&&void 0===T[e].count||(t+=`:${T[e].start}:${T[e].count}`),s.attributes.has(t)?n.indices=s.attributes.get(t):(n.indices=this.processAccessor(u.index,u,T[e].start,T[e].count),s.attributes.set(t,n.indices)),null===n.indices&&delete n.indices}const i=T[e].materialIndex;if(void 0!==i&&Array.isArray(w)){const e=w[i];if(!Array.isArray(e)){const t=this.processMaterial(e);null!==t&&(n.material=t),d.push(n)}}}p.primitives=d,n.meshes||(n.meshes=[]),this._invokeAll((function(t){t.writeMesh&&t.writeMesh(e,p)}));const v=n.meshes.push(p)-1;return s.meshes.set(h,v),v}processCamera(e){const s=this.json;s.cameras||(s.cameras=[]);const n=e instanceof t.OrthographicCamera&&e.isOrthographicCamera,i={type:n?"orthographic":"perspective"};return e instanceof t.OrthographicCamera&&n?i.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:e instanceof t.PerspectiveCamera&&(i.perspective={aspectRatio:e.aspect,yfov:t.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}),""!==e.name&&(i.name=e.type),s.cameras.push(i)-1}processAnimation(e,s){const n=this.json,r=this.nodeMap;n.animations||(n.animations=[]);const a=(e=i.Utils.mergeMorphTargetTracks(e.clone(),s)).tracks,o=[],l=[];for(let e=0;e<a.length;++e){const n=a[e],i=t.PropertyBinding.parseTrackName(n.name);let c=t.PropertyBinding.findNode(s,i.nodeName);const h=L[i.propertyName];if("bones"===i.objectName&&(c=c.isSkinnedMesh?c.skeleton.getBoneByName(i.objectIndex):void 0),!c||!h)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',n.name),null;const u=1;let f,p=n.values.length/n.times.length;h===L.morphTargetInfluences&&(p/=c.morphTargetInfluences.length),n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(f="CUBICSPLINE",p/=3):f=n.getInterpolation()===t.InterpolateDiscrete?"STEP":"LINEAR",l.push({input:this.processAccessor(new t.BufferAttribute(n.times,u)),output:this.processAccessor(new t.BufferAttribute(n.values,p)),interpolation:f}),o.push({sampler:l.length-1,target:{node:r.get(c),path:h}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:l,channels:o}),n.animations.length-1}processSkin(e){const s=this.json,n=this.nodeMap;if(void 0!==s.nodes&&e instanceof t.SkinnedMesh){const i=s.nodes[n.get(e)],r=e.skeleton;if(void 0===r)return null;const a=e.skeleton.bones[0];if(void 0===a)return null;const o=[],l=new Float32Array(16*r.bones.length),c=new t.Matrix4;for(let t=0;t<r.bones.length;++t)o.push(n.get(r.bones[t])),c.copy(r.boneInverses[t]),c.multiply(e.bindMatrix).toArray(l,16*t);void 0===s.skins&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new t.BufferAttribute(l,16)),joints:o,skeleton:n.get(a)});return i.skin=s.skins.length-1}return null}processNode(e){const s=this.json,n=this.options,i=this.nodeMap;s.nodes||(s.nodes=[]);const r={};if(n.trs){const t=e.quaternion.toArray(),s=e.position.toArray(),n=e.scale.toArray();this.equalArray(t,[0,0,0,1])||(r.rotation=t),this.equalArray(s,[0,0,0])||(r.translation=s),this.equalArray(n,[1,1,1])||(r.scale=n)}else e.matrixAutoUpdate&&e.updateMatrix(),this.isIdentityMatrix(e.matrix)||(r.matrix=e.matrix.elements);if(""!==e.name&&(r.name=String(e.name)),this.serializeUserData(e,r),(e instanceof t.Mesh&&e.isMesh||e instanceof t.Line&&e.isLine||e instanceof t.Points&&e.isPoints)&&e instanceof t.Mesh){const t=this.processMesh(e);null!==t&&(r.mesh=t)}else e instanceof t.Camera&&e.isCamera&&(r.camera=this.processCamera(e));if(e instanceof t.SkinnedMesh&&e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let s=0,i=e.children.length;s<i;s++){const i=e.children[s];if(i.visible||!n.onlyVisible){const e=this.processNode(i);null!==e&&t.push(e)}}t.length>0&&(r.children=t)}this._invokeAll((function(t){t.writeNode&&t.writeNode(e,r)}));const a=s.nodes.push(r)-1;return i.set(e,a),a}processScene(e){const t=this.json,s=this.options;t.scenes||(t.scenes=[],t.scene=0);const n={};""!==e.name&&(n.name=e.name),t.scenes.push(n);const i=[];for(let t=0,n=e.children.length;t<n;t++){const n=e.children[t];if(n.visible||!s.onlyVisible){const e=this.processNode(n);null!==e&&i.push(e)}}i.length>0&&(n.nodes=i),this.serializeUserData(e,n)}processObjects(e){const s=new t.Scene;s.name="AuxScene";for(let t=0;t<e.length;t++)s.children.push(e[t]);this.processScene(s)}processInput(e){const s=this.options;e=e instanceof Array?e:[e],this._invokeAll((function(t){t.beforeParse&&t.beforeParse(e)}));const n=[];for(let s=0;s<e.length;s++){const i=e[s];i instanceof t.Scene?this.processScene(i):n.push(e[s])}n.length>0&&this.processObjects(n);for(let e=0;e<this.skins.length;++e)this.processSkin(this.skins[e]);for(let t=0;void 0!==s.animations&&t<s.animations.length;++t)this.processAnimation(s.animations[t],e[0]);this._invokeAll((function(t){t.afterParse&&t.afterParse(e)}))}_invokeAll(e){for(let t=0,s=this.plugins.length;t<s;t++)e(this.plugins[t])}equalArray(e,t){return e.length===t.length&&e.every((function(e,s){return e===t[s]}))}stringToArrayBuffer(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;const t=new Uint8Array(new ArrayBuffer(e.length));for(let s=0,n=e.length;s<n;s++){const n=e.charCodeAt(s);t[s]=n>255?32:n}return t.buffer}isIdentityMatrix(e){return this.equalArray(e.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}getMinMax(e,t,s){const n={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=t;i<t+s;i++)for(let t=0;t<e.itemSize;t++){let s;e.itemSize>4?s=e.array[i*e.itemSize+t]:0===t?s=e.getX(i):1===t?s=e.getY(i):2===t?s=e.getZ(i):3===t&&(s=e.getW(i)),void 0!==s&&(n.min[t]=Math.min(n.min[t],s),n.max[t]=Math.max(n.max[t],s))}return n}getPaddedBufferSize(e){return 4*Math.ceil(e/4)}getPaddedArrayBuffer(e,t=0){const s=this.getPaddedBufferSize(e.byteLength);if(s!==e.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(e)),0!==t)for(let i=e.byteLength;i<s;i++)n[i]=t;return n.buffer}return e}}class I{constructor(e){n.default(this,"writer",void 0),n.default(this,"name",void 0),this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,s){if(!e.isLight)return;if(!(e instanceof t.DirectionalLight&&e.isDirectionalLight||e instanceof t.PointLight&&e.isPointLight||e instanceof t.SpotLight&&e.isSpotLight))return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const n=this.writer,i=n.json,r=n.extensionsUsed,a={};if(e.name&&(a.name=e.name),a.color=e.color.toArray(),a.intensity=e.intensity,e instanceof t.DirectionalLight&&e.isDirectionalLight?a.type="directional":e instanceof t.PointLight&&e.isPointLight?(a.type="point",e.distance>0&&(a.range=e.distance)):e instanceof t.SpotLight&&e.isSpotLight&&(a.type="spot",e.distance>0&&(a.range=e.distance),a.spot={},a.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,a.spot.outerConeAngle=e.angle),e instanceof t.DirectionalLight||void 0===e.decay||2===e.decay||console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e instanceof t.PointLight||!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(i.extensions=i.extensions||{},i.extensions[this.name]={lights:[]},r[this.name]=!0),void 0!==i.extensions){const e=i.extensions[this.name].lights;e.push(a),s.extensions=s.extensions||{},s.extensions[this.name]={light:e.length-1}}}}class R{constructor(e){n.default(this,"writer",void 0),n.default(this,"name",void 0),this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,s){if(!(e instanceof t.MeshBasicMaterial&&e.isMeshBasicMaterial))return;const n=this.writer.extensionsUsed;s.extensions=s.extensions||{},s.extensions[this.name]={},n[this.name]=!0,s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=.9}}class F{constructor(e){n.default(this,"writer",void 0),n.default(this,"name",void 0),this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,s){if(!e.isGLTFSpecularGlossinessMaterial)return;const n=this.writer,i=n.extensionsUsed,r={};if(s.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=s.pbrMetallicRoughness.baseColorFactor),e instanceof t.MeshPhongMaterial){const t=[1,1,1];e.specular.toArray(t,0),r.specularFactor=t,r.glossinessFactor=e.glossiness}if(s.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=s.pbrMetallicRoughness.baseColorTexture),(e instanceof t.MeshBasicMaterial||e instanceof t.MeshLambertMaterial||e instanceof t.MeshPhongMaterial)&&e.specularMap){const t={index:n.processTexture(e.specularMap)};n.applyTextureTransform(t,e.specularMap),r.specularGlossinessTexture=t}s.extensions=s.extensions||{},s.extensions[this.name]=r,i[this.name]=!0}}class N{constructor(e){n.default(this,"writer",void 0),n.default(this,"name",void 0),this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,s){if(!(e instanceof t.MeshPhysicalMaterial&&e.isMeshPhysicalMaterial)||0===e.transmission)return;const n=this.writer,i=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const t={index:n.processTexture(e.transmissionMap)};n.applyTextureTransform(t,e.transmissionMap),r.transmissionTexture=t}s.extensions=s.extensions||{},s.extensions[this.name]=r,i[this.name]=!0}}class B{constructor(e){n.default(this,"writer",void 0),n.default(this,"name",void 0),this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,s){if(!(e instanceof t.MeshPhysicalMaterial&&e.isMeshPhysicalMaterial)||0===e.thickness)return;const n=this.writer,i=n.extensionsUsed,r={};if(r.thickness=e.thickness,e.thicknessMap){const t={index:n.processTexture(e.thicknessMap)};n.applyTextureTransform(t,e.thicknessMap),r.thicknessTexture=t}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationTint.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,i[this.name]=!0}}exports.GLTFExporter=i;
