"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@babel/runtime/helpers/defineProperty"),e=require("three");function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var o=i(t);class r extends e.Object3D{constructor(t,i=[]){function r(t){return new e.Line(function(t){const i=new e.BufferGeometry,o=new Float32Array(3*(2+t.links.length));return i.setAttribute("position",new e.BufferAttribute(o,3)),i}(t),scope.lineMaterial)}super(),o.default(this,"_m",new e.Matrix4),o.default(this,"_v",new e.Vector3),this.root=t,this.iks=i,this.matrix.copy(t.matrixWorld),this.matrixAutoUpdate=!1,this.sphereGeometry=new e.SphereGeometry(.25,16,8),this.targetSphereMaterial=new e.MeshBasicMaterial({color:new e.Color(16746632),depthTest:!1,depthWrite:!1,transparent:!0}),this.effectorSphereMaterial=new e.MeshBasicMaterial({color:new e.Color(8978312),depthTest:!1,depthWrite:!1,transparent:!0}),this.linkSphereMaterial=new e.MeshBasicMaterial({color:new e.Color(8947967),depthTest:!1,depthWrite:!1,transparent:!0}),this.lineMaterial=new e.LineBasicMaterial({color:new e.Color(16711680),depthTest:!1,depthWrite:!1,transparent:!0});for(let t=0,o=i.length;t<o;t++){const o=i[t];this.add(new e.Mesh(scope.sphereGeometry,scope.targetSphereMaterial)),this.add(new e.Mesh(scope.sphereGeometry,scope.effectorSphereMaterial));for(let t=0,i=o.links.length;t<i;t++)this.add(new e.Mesh(scope.sphereGeometry,scope.linkSphereMaterial));this.add(r(o))}}_getPosition(t,e){return this._v.setFromMatrixPosition(t.matrixWorld).applyMatrix4(e)}_setPositionOfBoneToAttributeArray(t,e,i,o){const r=this._getPosition(i,o);t[3*e+0]=r.x,t[3*e+1]=r.y,t[3*e+2]=r.z}updateMatrixWorld(t){const e=this.root;if(this.visible){let t=0;const i=this.iks,o=e.skeleton.bones;this._m.copy(e.matrixWorld).invert();for(let e=0,r=i.length;e<r;e++){const r=i[e],s=o[r.target],n=o[r.effector],a=this.children[t++],h=this.children[t++];a.position.copy(this._getPosition(s,this._m)),h.position.copy(this._getPosition(n,this._m));for(let e=0,i=r.links.length;e<i;e++){const i=o[r.links[e].index];this.children[t++].position.copy(this._getPosition(i,this._m))}const l=this.children[t++],c=l.geometry.attributes.position.array;this._setPositionOfBoneToAttributeArray(c,0,s,this._m),this._setPositionOfBoneToAttributeArray(c,1,n,this._m);for(let t=0,e=r.links.length;t<e;t++){const e=o[r.links[t].index];this._setPositionOfBoneToAttributeArray(c,t+2,e,this._m)}l.geometry.attributes.position.needsUpdate=!0}}this.matrix.copy(e.matrixWorld),super.updateMatrixWorld(t)}}exports.CCDIKHelper=r,exports.CCDIKSolver=class{constructor(t,i){o.default(this,"q",new e.Quaternion),o.default(this,"targetPos",new e.Vector3),o.default(this,"targetVec",new e.Vector3),o.default(this,"effectorPos",new e.Vector3),o.default(this,"effectorVec",new e.Vector3),o.default(this,"linkPos",new e.Vector3),o.default(this,"invLinkQ",new e.Quaternion),o.default(this,"linkScale",new e.Vector3),o.default(this,"axis",new e.Vector3),o.default(this,"vector",new e.Vector3),this.mesh=t,this.iks=i;const r=this.mesh.skeleton.bones;for(let t=0,e=this.iks.length;t<e;t++){const e=this.iks[t],i=r[e.effector],o=e.links;let s,n;s=i;for(let t=0,e=o.length;t<e;t++)n=r[o[t].index],s.parent!==n&&console.warn(`THREE.CCDIKSolver: bone ${s.name} is not the child of bone ${n.name}`),s=n}}update(){const t=this.mesh.skeleton.bones,e=this.iks,i=Math;for(let o=0,r=e.length;o<r;o++){const r=e[o],s=t[r.effector],n=t[r.target];this.targetPos.setFromMatrixPosition(n.matrixWorld);const a=r.links,h=void 0!==r.iteration?r.iteration:1;for(let e=0;e<h;e++){let e=!1;for(let o=0,n=a.length;o<n;o++){const n=t[a[o].index];if(!1===a[o].enabled)break;const h=a[o].limitation,l=a[o].rotationMin,c=a[o].rotationMax;n.matrixWorld.decompose(this.linkPos,this.invLinkQ,this.linkScale),this.invLinkQ.invert(),this.effectorPos.setFromMatrixPosition(s.matrixWorld),this.effectorVec.subVectors(this.effectorPos,this.linkPos),this.effectorVec.applyQuaternion(this.invLinkQ),this.effectorVec.normalize(),this.targetVec.subVectors(this.targetPos,this.linkPos),this.targetVec.applyQuaternion(this.invLinkQ),this.targetVec.normalize();let f=this.targetVec.dot(this.effectorVec);if(f>1?f=1:f<-1&&(f=-1),f=i.acos(f),!(f<1e-5)){if(void 0!==r.minAngle&&f<r.minAngle&&(f=r.minAngle),void 0!==r.maxAngle&&f>r.maxAngle&&(f=r.maxAngle),this.axis.crossVectors(this.effectorVec,this.targetVec),this.axis.normalize(),this.q.setFromAxisAngle(this.axis,f),n.quaternion.multiply(this.q),void 0!==h){let t=n.quaternion.w;t>1&&(t=1);const e=i.sqrt(1-t*t);n.quaternion.set(h.x*e,h.y*e,h.z*e,t)}void 0!==l&&n.rotation.setFromVector3(n.rotation.toVector3(this.vector).max(l)),void 0!==c&&n.rotation.setFromVector3(n.rotation.toVector3(this.vector).min(c)),n.updateMatrixWorld(!0),e=!0}}if(!e)break}}return this}createHelper(){return new r(this.mesh,this.mesh.geometry.userData.MMD.iks)}};
