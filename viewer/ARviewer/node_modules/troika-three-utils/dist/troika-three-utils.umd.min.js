'use strict';(function(f,d){"object"===typeof exports&&"undefined"!==typeof module?d(exports,require("three")):"function"===typeof define&&define.amd?define(["exports","three"],d):(f="undefined"!==typeof globalThis?globalThis:f||self,d(f.troika_three_utils={},f.THREE))})(this,function(f,d){function q(a){return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,function(a,g){return(g=d.ShaderChunk[g])?q(g):a})}function l(a,b){let g=C(b),c=n.get(a);c||n.set(a,c=Object.create(null));if(c[g])return new c[g];
let t=`_onBeforeCompile${g}`,f=function(h){a.onBeforeCompile.call(this,h);const c=this.customProgramCacheKey()+"|"+h.vertexShader+"|"+h.fragmentShader;var d=v[c];d||(d=D(h,b,g),d=v[c]=d);h.vertexShader=d.vertexShader;h.fragmentShader=d.fragmentShader;k(h.uniforms,this.uniforms);b.timeUniform&&(h.uniforms[b.timeUniform]={get value(){return Date.now()-E}});if(this[t])this[t](h)},u=function(){return m(b.chained?a:a.clone())},m=function(h){const c=Object.create(h,F);Object.defineProperty(c,"baseMaterial",
{value:a});Object.defineProperty(c,"id",{value:G++});{var d=4294967295*Math.random()|0;let a=4294967295*Math.random()|0,b=4294967295*Math.random()|0,c=4294967295*Math.random()|0;d=(e[d&255]+e[d>>8&255]+e[d>>16&255]+e[d>>24&255]+"-"+e[a&255]+e[a>>8&255]+"-"+e[a>>16&15|64]+e[a>>24&255]+"-"+e[b&63|128]+e[b>>8&255]+"-"+e[b>>16&255]+e[b>>24&255]+e[c&255]+e[c>>8&255]+e[c>>16&255]+e[c>>24&255]).toUpperCase()}c.uuid=d;c.uniforms=k({},h.uniforms,b.uniforms);c.defines=k({},h.defines,b.defines);c.defines[`TROIKA_DERIVED_MATERIAL_${g}`]=
"";c.extensions=k({},h.extensions,b.extensions);c._listeners=void 0;return c},F={constructor:{value:u},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return a.customProgramCacheKey()+"|"+g}},onBeforeCompile:{get(){return f},set(a){this[t]=a}},copy:{writable:!0,configurable:!0,value:function(b){a.copy.call(this,b);a.isShaderMaterial||a.isDerivedMaterial||(k(this.extensions,b.extensions),k(this.defines,b.defines),k(this.uniforms,d.UniformsUtils.clone(b.uniforms)));
return this}},clone:{writable:!0,configurable:!0,value:function(){const b=new a.constructor;return m(b).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let c=this._depthMaterial;c||(c=this._depthMaterial=l(a.isDerivedMaterial?a.getDepthMaterial():new d.MeshDepthMaterial({depthPacking:d.RGBADepthPacking}),b),c.defines.IS_DEPTH_MATERIAL="",c.uniforms=this.uniforms);return c}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let c=this._distanceMaterial;c||
(c=this._distanceMaterial=l(a.isDerivedMaterial?a.getDistanceMaterial():new d.MeshDistanceMaterial,b),c.defines.IS_DISTANCE_MATERIAL="",c.uniforms=this.uniforms);return c}},dispose:{writable:!0,configurable:!0,value(){const {_depthMaterial:b,_distanceMaterial:c}=this;b&&b.dispose();c&&c.dispose();a.dispose.call(this)}}};c[g]=u;return new u}function D({vertexShader:a,fragmentShader:b},d,c){let {vertexDefs:g,vertexMainIntro:e,vertexMainOutro:f,vertexTransform:m,fragmentDefs:k,fragmentMainIntro:h,fragmentMainOutro:p,
fragmentColorTransform:l,customRewriter:r,timeUniform:n}=d;g=g||"";e=e||"";f=f||"";k=k||"";h=h||"";p=p||"";if(m||r)a=q(a);if(l||r)b=b.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,"\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"),b=q(b);r&&(b=r({vertexShader:a,fragmentShader:b}),a=b.vertexShader,b=b.fragmentShader);if(l){let a=[];b=b.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,b=>{a.push(b);return""});p=`${l}\n${a.join("\n")}\n${p}`}n&&
(d=`\nuniform float ${n};\n`,g=d+g,k=d+k);m&&(g=`${g}
void troikaVertexTransform${c}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${m}
}
`,e=`
troika_position_${c} = vec3(position);
troika_normal_${c} = vec3(normal);
troika_uv_${c} = vec2(uv);
troikaVertexTransform${c}(troika_position_${c}, troika_normal_${c}, troika_uv_${c});
${e}
`,a=`vec3 troika_position_${c};
vec3 troika_normal_${c};
vec2 troika_uv_${c};
${a}
`.replace(/\b(position|normal|uv)\b/g,(a,b,d,g)=>/\battribute\s+vec[23]\s+$/.test(g.substr(0,d))?b:`troika_${b}_${c}`));a=w(a,c,g,e,f);b=w(b,c,k,h,p);return{vertexShader:a,fragmentShader:b}}function w(a,b,d,c,e){if(c||e||d)a=a.replace(x,`
${d}
void troikaOrigMain${b}() {`),a+=`
void main() {
  ${c}
  troikaOrigMain${b}();
  ${e}
}`;return a}function H(a,b){return"uniforms"===a?void 0:"function"===typeof b?b.toString():b}function C(a){a=JSON.stringify(a,H);let b=y.get(a);null==b&&y.set(a,b=++I);return b}let x=/\bvoid\s+main\s*\(\s*\)\s*{/g,e=[];for(let a=0;256>a;a++)e[a]=(16>a?"0":"")+a.toString(16);let k=Object.assign||function(){let a=arguments[0];for(let b=1,d=arguments.length;b<d;b++){let c=arguments[b];if(c)for(let b in c)c.hasOwnProperty(b)&&(a[b]=c[b])}return a},E=Date.now(),n=new WeakMap,v=new Map,G=1E10,I=0,y=new Map,
J={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},z=null,A=new d.MeshStandardMaterial({color:16777215,side:d.DoubleSide});class B extends d.Mesh{static getGeometry(){return z||
(z=(new d.CylinderBufferGeometry(1,1,1,6,64)).translate(0,.5,0))}constructor(){super(B.getGeometry(),A);this.pointA=new d.Vector3;this.controlA=new d.Vector3;this.controlB=new d.Vector3;this.pointB=new d.Vector3;this.radius=.01;this.dashArray=new d.Vector2;this.dashOffset=0;this.frustumCulled=!1}get material(){let a=this._derivedMaterial,b=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=A.clone());a&&a.baseMaterial===b||(a=this._derivedMaterial=l(b,{chained:!0,uniforms:{pointA:{value:new d.Vector3},
controlA:{value:new d.Vector3},controlB:{value:new d.Vector3},pointB:{value:new d.Vector3},radius:{value:.01},dashing:{value:new d.Vector3}},vertexDefs:"\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n",
vertexTransform:'\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make "sideways" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won\'t see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n',
fragmentDefs:"\nuniform vec3 dashing;\nvarying float bezierT;\n",fragmentMainIntro:"\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n"}),b.addEventListener("dispose",function c(){b.removeEventListener("dispose",c);a.dispose()}));return a}set material(a){this._baseMaterial=a}get customDepthMaterial(){return this.material.getDepthMaterial()}get customDistanceMaterial(){return this.material.getDistanceMaterial()}onBeforeRender(a){({uniforms:a}=
this.material);let {pointA:b,controlA:d,controlB:c,pointB:e,radius:f,dashArray:k,dashOffset:l}=this;a.pointA.value.copy(b);a.controlA.value.copy(d);a.controlB.value.copy(c);a.pointB.value.copy(e);a.radius.value=f;a.dashing.value.set(k.x,k.y,l||0)}raycast(a,b){}}f.BezierMesh=B;f.createDerivedMaterial=l;f.expandShaderIncludes=q;f.getShaderUniformTypes=function(a){let b=/\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g,d=Object.create(null),c;for(;null!==(c=b.exec(a));)d[c[2]]=c[1];return d};
f.getShadersForMaterial=function(a){let b=J[a.type];return b?d.ShaderLib[b]:a};f.invertMatrix4=function(a,b=new d.Matrix4){"function"===typeof b.invert?b.copy(a).invert():b.getInverse(a);return b};f.voidMainRegExp=x;Object.defineProperty(f,"__esModule",{value:!0})})
